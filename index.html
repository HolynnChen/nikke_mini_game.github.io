<!doctype html>
<html>

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>9x9 背包堆积可视化</title>
  <style>
    :root {
      --bg: #f6f8fb;
      --card-bg: #ffffff;
      --text: #1f2937;
      --muted: #6b7280;
      --primary: #3b82f6;
      --primary-700: #2563eb;
      --border: #e5e7eb;
    }

    * {
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, system-ui, Segoe UI, Roboto, sans-serif;
      margin: 0;
      min-height: 100vh;
      background: linear-gradient(180deg, #eef2ff 0%, #f8fafc 100%);
      color: var(--text);
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .page {
      width: 100%;
      max-width: 1080px;
      padding: 24px;
    }

    h2 {
      text-align: center;
      margin: 0 0 6px;
      font-weight: 700;
      letter-spacing: 0.2px;
    }

    .small {
      color: var(--muted);
      font-size: 13px;
      text-align: center;
      margin-bottom: 16px;
    }

    .container {
      display: grid;
      gap: 20px;
      grid-template-columns: 1fr 400px 1fr;
      align-items: start;
    }





    .panel {
      background: var(--card-bg);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 16px;
      box-shadow: 0 6px 24px rgba(0, 0, 0, 0.06);
    }

    .panel h3 {
      margin: 0;
      font-size: 16px;
    }

    .panel-head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      margin-bottom: 12px;
      min-height: 24px;
    }

    .panel-head .button-group {
      display: flex;
      gap: 8px;
      margin-left: auto;
    }

    .panel-head .button-group button {
      padding: 6px 10px;
      font-size: 13px;
      font-weight: 500;
    }

    .grid {
      display: grid;
      gap: 6px;
      justify-content: center;
    }

    .cell {
      width: 30px;
      height: 30px;
      display: flex;
      align-items: center;
      justify-content: center;
      border: 1px solid var(--border);
      cursor: pointer;
      user-select: none;
      border-radius: 6px;
      transition: background 0.15s, transform 0.05s;
      font-weight: 600;
    }

    .cell.block {
      background: #111827;
      color: #fff;
      border-color: #111827;
    }

    .cell.free {
      background: #ffffff;
    }

    .cell.free:hover {
      background: #f3f6ff;
    }

    .cell:active {
      transform: scale(0.98);
    }

    .resultGrid .cell {
      width: 26px;
      height: 26px;
    }

    .resultGrid .cell {
      position: relative;
    }

    .row {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      background: #f8fafc;
      border-radius: 8px;
      border: 1px solid #e2e8f0;
      min-width: 0; /* 允许flex项目收缩 */
    }

    #shapes {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 8px;
      padding: 4px;
    }



    .shape {
      display: inline-grid;
      gap: 2px;
      padding: 6px;
      background: #ffffff;
      border: 1px solid #d1d5db;
      border-radius: 6px;
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
    }


    .sq {
      width: 10px;
      height: 10px;
      border: 1px solid #cbd5e1;
      border-radius: 2px;
      background: #fff;
    }

    .sq.on {
      background: #64748b;
    }

    .controls {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
      justify-content: center;
      margin-top: 12px;
    }

    select,
    input[type="number"] {
      appearance: none;
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 6px 10px;
      font-size: 14px;
      background: #fff;
      color: var(--text);
    }

    input[type="number"] {
      width: 80px;
    }

    button {
      border: 0;
      background: var(--primary);
      color: #fff;
      padding: 8px 12px;
      border-radius: 10px;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.15s, transform 0.05s;
    }

    button:hover {
      background: var(--primary-700);
    }

    button:active {
      transform: translateY(1px);
    }

    /* 取消按钮样式 */
    button.cancel {
      background: #dc2626;
    }

    button.cancel:hover {
      background: #b91c1c;
    }

    .util {
      display: flex;
      justify-content: center;
      align-items: baseline;
      gap: 8px;
      margin: 8px 0 12px;
    }

    .util strong {
      font-size: 20px;
      color: var(--primary-700);
    }

    .solutions {
      display: flex;
      align-items: center;
      gap: 10px;
      justify-content: center;
      margin: 8px 0;
    }

    .summary {
      margin-top: 10px;
      color: var(--muted);
      font-size: 13px;
      text-align: center;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-wrap: wrap;
      line-height: 1.4;
    }


    .progress-container {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-left: auto;
      height: 100%;
    }

    .progress-bar {
      width: 80px;
      height: 6px;
      background: #e5e7eb;
      border-radius: 3px;
      overflow: hidden;
      position: relative;
    }

    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, var(--primary) 0%, var(--primary-700) 100%);
      border-radius: 3px;
      width: 0%;
      transition: width 0.2s ease-out;
    }

    .progress-text {
      font-size: 11px;
      color: var(--muted);
      font-weight: 500;
      min-width: 28px;
      text-align: right;
    }

    .footer {
      color: var(--muted);
      font-size: 12px;
      margin-top: 14px;
      text-align: center;
    }

    .result-overlay {
      position: absolute;
      top: 50px;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(255, 255, 255, 0.9);
      backdrop-filter: blur(2px);
      display: none;
      align-items: center;
      justify-content: center;
      border-radius: 0 0 12px 12px;
      z-index: 10;
    }

    .result-overlay.show {
      display: flex;
    }

    .loading-spinner {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 16px;
    }

    .spinner {
      width: 40px;
      height: 40px;
      border: 3px solid #e5e7eb;
      border-top: 3px solid var(--primary);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .loading-text {
      color: var(--muted);
      font-size: 14px;
      font-weight: 500;
    }

    /* 确保结果面板有相对定位 */
    .result-panel {
      position: relative;
    }

    /* 拖动矩形选择功能样式 */
    .grid-container {
      position: relative;
      display: inline-block;
    }

    .selection-overlay {
      position: absolute;
      border: 2px dashed var(--primary);
      background: rgba(59, 130, 246, 0.1);
      pointer-events: none;
      z-index: 5;
      display: none;
    }

    .grid {
      user-select: none;
    }

    @media (max-width: 1200px) {
      .container {
        grid-template-columns: 1fr 1fr;
      }

      
      #shapes {
        grid-template-columns: repeat(2, minmax(0, 1fr)); /* 在两列布局时保持两列 */
      }
      
      .row {
        gap: 10px; /* 增加间距 */
        padding: 8px 12px;
      }
      
      input[type="number"] {
        width: 70px !important; /* 恢复较大的输入框 */
      }
    }



    @media (max-width: 900px) {
      .container {
        grid-template-columns: 1fr;
      }

      #shapes {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }
      
      .row {
        gap: 12px;
        padding: 10px 14px;
      }
      
      input[type="number"] {
        width: 80px !important;
      }
    }



  </style>
</head>

<body>
  <div class="page">
    <h2>9x9 背包堆积可视化</h2>
    <div class="small">点击网格切换可用/不可用(x)。设置各形状数量，实时计算并展示最优堆积方案及利用率。最佳用途：帮你填缝。</div>

    <div class="container">
      <div class="panel">
        <h3>背包 9x9</h3>
        <div class="grid-container">
          <div id="grid" class="grid"></div>
          <div id="selectionOverlay" class="selection-overlay"></div>
        </div>
        <div class="controls">
          <button id="clear">重置背包状态</button>
          <button id="fill">全部可用</button>
        </div>
      </div>
      <div class="panel">
        <div class="panel-head">
          <h3>物体数量</h3>
          <div class="button-group">
            <button id="clearCounts">清空物品数量</button>
            <button id="calculate">计算结果</button>
          </div>
        </div>
        <div id="shapes"></div>
      </div>
      <div class="panel result-panel">
        <div class="panel-head">
          <h3>结果</h3>
          <div class="progress-container" id="progressContainer" style="display: none;">
            <div class="progress-bar">
              <div class="progress-fill" id="progressFill"></div>
            </div>
            <span class="progress-text" id="progressText">0%</span>
          </div>
        </div>
        <div id="util" class="util">利用率: --</div>
        <div class="solutions">
          <span id="solutionCount">解法：0种</span>
          <label>选择:
            <select id="solutionSelect"></select>
          </label>
        </div>
        <div id="vis" class="grid resultGrid"></div>
        <div id="countsSummary" class="summary"></div>
        <div class="result-overlay" id="resultOverlay">
          <div class="loading-spinner">
            <div class="spinner"></div>
            <div class="loading-text">正在计算最优方案...</div>
          </div>
        </div>
      </div>
    </div>


    <div class="footer">说明：物体不可旋转；字母表示不同形状的摆放；空余可用位置显示为空，障碍显示为 x。</div>
  </div>

  <script>
    // Worker 池管理器 - 内联版本
    class WorkerPool {
      constructor(workerScript, maxWorkers = null) {
        this.workerScript = workerScript;
        this.maxWorkers = maxWorkers || navigator.hardwareConcurrency || 4;
        this.workers = [];
        this.workerStates = new Map(); // workerId -> 'available' | 'busy' | 'initializing'
        this.isInitialized = false;
        
        // 动态任务分配相关
        this.taskQueue = [];
        this.currentTaskIndex = 0;
        this.totalTasks = 0;
        this.completedTasks = 0;
        this.allResults = [];
        this.globalProgressCallback = null;
        this.taskResolve = null;
        this.taskReject = null;
        this.isCancelled = false;
        this.taskId = 0;
        this.pendingTasks = new Map();
      }
      // 初始化 Worker 池
      async init() {
        if (this.isInitialized) return;
        
        console.log(`初始化 Worker 池，创建 ${this.maxWorkers} 个 Worker`);
        
        // 创建 Worker 实例
        for (let i = 0; i < this.maxWorkers; i++) {
          const worker = new Worker(this.workerScript, { type: 'module' });
          worker.workerId = i;
          
          // 设置消息处理器
          worker.onmessage = (e) => this.handleWorkerMessage(worker, e);
          worker.onerror = (error) => this.handleWorkerError(worker, error);
          
          this.workers.push(worker);
          this.workerStates.set(i, 'initializing');
        }
        
        // 初始化所有 Worker 中的 WASM 模块
        const initPromises = this.workers.map(worker => {
          return new Promise((resolve, reject) => {
            const taskId = ++this.taskId;
            this.pendingTasks.set(taskId, { resolve, reject, type: 'init' });
            
            worker.postMessage({
              type: 'init',
              taskId
            });
          });
        });
        
        await Promise.all(initPromises);
        
        // 将所有 Worker 标记为可用
        for (let i = 0; i < this.maxWorkers; i++) {
          this.workerStates.set(i, 'available');
        }
        
        this.isInitialized = true;
        console.log('Worker 池初始化完成');
      }
      
      // 处理 Worker 消息
      handleWorkerMessage(worker, e) {
        const { type, taskId, ...data } = e.data;
        const task = this.pendingTasks.get(taskId);
        
        switch (type) {
          case 'init_complete':
            if (task) {
              this.pendingTasks.delete(taskId);
              if (data.success) {
                task.resolve();
              } else {
                task.reject(new Error('Worker 初始化失败'));
              }
            }
            break;
            
          case 'single_task_complete':
            this.handleSingleTaskComplete(worker, taskId, data);
            break;
            
          case 'cancel_complete':
            if (task) {
              this.pendingTasks.delete(taskId);
              this.setWorkerAvailable(worker);
              task.resolve();
            }
            break;
            
          case 'error':
            if (task) {
              this.pendingTasks.delete(taskId);
              this.setWorkerAvailable(worker);
              task.reject(new Error(data.error));
            }
            break;
        }
      }
      
      // 处理单个任务完成
      handleSingleTaskComplete(worker, taskId, data) {
        const task = this.pendingTasks.get(taskId);
        if (!task) return;
        
        this.pendingTasks.delete(taskId);
        
        // 收集结果
        if (data.results && data.results.length > 0) {
          this.allResults.push(...data.results);
        }
        
        // 更新进度
        this.completedTasks++;
        if (this.globalProgressCallback) {
          const progress = (this.completedTasks / this.totalTasks) * 100;
          this.globalProgressCallback(progress);
        }
        
        console.log(`Worker ${worker.workerId} 完成任务，进度: ${this.completedTasks}/${this.totalTasks}`);
        
        // 调用动态剪枝回调（如果存在）
        if (this.dynamicPruningCallback && data.results && data.results.length > 0) {
          const prunedCount = this.dynamicPruningCallback(data.results);
          if (prunedCount > 0) {
            console.log(`🔥 动态剪枝：移除了 ${prunedCount} 个待处理任务`);
            // 更新总任务数
            this.totalTasks -= prunedCount;
          }
        }
        
        // 检查是否所有任务都完成了
        if (this.completedTasks >= this.totalTasks) {
          console.log(`所有任务完成，共收集到 ${this.allResults.length} 个结果`);
          if (this.taskResolve) {
            this.taskResolve(this.allResults);
            this.taskResolve = null;
            this.taskReject = null;
          }
          this.setWorkerAvailable(worker);
          return;
        }
        
        // 为这个 Worker 分配下一个任务
        this.assignNextTask(worker);
      }
      
      // 处理 Worker 错误
      handleWorkerError(worker, error) {
        console.error(`Worker ${worker.workerId} 出错:`, error);
        
        // 如果是在动态任务分配过程中出错，尝试分配下一个任务
        if (this.currentTaskIndex < this.totalTasks && !this.isCancelled) {
          // 不需要先释放 Worker，直接分配下一个任务
          this.assignNextTask(worker);
        } else {
          // 如果没有更多任务，则将 Worker 设为可用
          this.setWorkerAvailable(worker);
        }
      }
      
      // 设置 Worker 为可用状态
      setWorkerAvailable(worker) {
        if (!worker || typeof worker.workerId === 'undefined') {
          console.warn('setWorkerAvailable: worker 参数无效');
          return;
        }
        
        this.workerStates.set(worker.workerId, 'available');
        // console.log(`Worker ${worker.workerId} 设为可用状态`);
      }
      
      // 设置 Worker 为忙碌状态
      setWorkerBusy(worker) {
        if (!worker || typeof worker.workerId === 'undefined') {
          console.warn('setWorkerBusy: worker 参数无效');
          return;
        }
        
        this.workerStates.set(worker.workerId, 'busy');
        // console.log(`Worker ${worker.workerId} 设为忙碌状态`);
      }
      
      // 检查 Worker 是否可用
      isWorkerAvailable(worker) {
        if (!worker || typeof worker.workerId === 'undefined') {
          return false;
        }
        
        return this.workerStates.get(worker.workerId) === 'available';
      }
      
      // 获取下一个可用的 Worker
      getNextAvailableWorker() {
        for (const worker of this.workers) {
          if (this.isWorkerAvailable(worker)) {
            return worker;
          }
        }
        return null;
      }
      
      // 获取可用 Worker 数量
      getAvailableWorkerCount() {
        let count = 0;
        for (const [workerId, state] of this.workerStates) {
          if (state === 'available') {
            count++;
          }
        }
        return count;
      }
      
      // 为 Worker 分配下一个任务
      assignNextTask(worker) {
        // 检查 Worker 对象是否有效
        if (!worker) {
          console.error('assignNextTask: worker 参数为空');
          return;
        }
        
        // 确保 workerId 存在
        if (typeof worker.workerId === 'undefined') {
          // 尝试从 workers 数组中找到对应的 workerId
          const workerIndex = this.workers.indexOf(worker);
          if (workerIndex !== -1) {
            worker.workerId = workerIndex;
          } else {
            console.warn('assignNextTask: 无法确定 worker ID，使用默认值');
            worker.workerId = 'unknown';
          }
        }
        
        // 检查是否已取消
        if (this.isCancelled) {
          this.setWorkerAvailable(worker);
          return;
        }
        
        // 检查是否还有任务
        if (this.currentTaskIndex >= this.taskQueue.length) {
          this.setWorkerAvailable(worker);
          return;
        }
        
        // 获取下一个任务
        const task = this.taskQueue[this.currentTaskIndex];
        this.currentTaskIndex++;
        
        // 标记 Worker 为忙碌
        this.setWorkerBusy(worker);
        
        // console.log(`Worker ${worker.workerId} 开始处理任务 ${this.currentTaskIndex}/${this.totalTasks}`);
        
        // 创建任务记录
        const taskId = ++this.taskId;
        this.pendingTasks.set(taskId, { 
          type: 'single_task',
          worker: worker,
          taskIndex: this.currentTaskIndex - 1
        });
        
        // 发送单个任务
        worker.postMessage({
          type: 'solve_single',
          data: {
            combination: task.combination,
            grid: task.grid,
            shapes: task.shapes,
            originalIndex: task.originalIndex
          },
          taskId
        });
      }
      
      // 动态任务分配 - 主要接口
      async solveDynamic(combinations, grid, shapes, progressCallback, dynamicPruningCallback) {
        if (!this.isInitialized) {
          await this.init();
        }
        
        if (combinations.length === 0) {
          return [];
        }
        
        console.log(`开始动态任务分配，总共 ${combinations.length} 个组合`);
        
        // 重置状态
        this.currentTaskIndex = 0;
        this.totalTasks = combinations.length;
        this.completedTasks = 0;
        this.allResults = [];
        this.globalProgressCallback = progressCallback;
        this.dynamicPruningCallback = dynamicPruningCallback;
        this.isCancelled = false;
        
        // 创建任务队列
        this.taskQueue = combinations.map((combination, index) => ({
          combination: combination.combination,
          originalIndex: combination.originalIndex,
          grid: grid,
          shapes: shapes,
          taskIndex: index
        }));
        
        return new Promise((resolve, reject) => {
          this.taskResolve = resolve;
          this.taskReject = reject;
          
          // 启动所有可用的 Worker
          const availableWorkerCount = this.getAvailableWorkerCount();
          const workersToStart = Math.min(availableWorkerCount, this.taskQueue.length);
          console.log(`准备启动 ${workersToStart} 个 Worker，可用 Worker 数量: ${availableWorkerCount}`);
          
          let startedWorkers = 0;
          for (const worker of this.workers) {
            if (startedWorkers >= workersToStart) break;
            
            if (this.isWorkerAvailable(worker)) {
              // console.log(`启动 Worker ${worker.workerId} 处理任务`);
              this.assignNextTask(worker);
              startedWorkers++;
            }
          }
          
          if (startedWorkers === 0) {
            console.warn('没有可用的 Worker 来处理任务');
            reject(new Error('没有可用的 Worker'));
          }
        });
      }
      
      // 取消所有任务
      async cancelAll() {
        console.log('取消所有 Worker 任务 - 直接终止并重建');
        
        try {
          // 设置取消标记
          this.isCancelled = true;
          
          // 如果有待解决的 Promise，优雅地解决它而不是拒绝
          if (this.taskResolve) {
            console.log('优雅地结束当前计算任务');
            this.taskResolve([]); // 返回空结果而不是抛出异常
            this.taskResolve = null;
            this.taskReject = null;
          }
          
          // 直接终止所有 Worker
          this.workers.forEach((worker, index) => {
            try {
              console.log(`终止 Worker ${index}`);
              worker.terminate();
            } catch (error) {
              console.warn(`终止 Worker ${index} 时出现警告:`, error.message);
            }
          });
          
          // 清理所有状态
          this.workers = [];
          this.workerStates.clear();
          this.pendingTasks.clear();
          this.currentTaskIndex = 0;
          this.totalTasks = 0;
          this.completedTasks = 0;
          this.allResults = [];
          this.taskQueue = [];
          this.taskId = 0;
          this.globalProgressCallback = null;
          this.dynamicPruningCallback = null;
          this.isInitialized = false;
          
          // 重新初始化 Worker 池
          console.log('重新初始化 Worker 池');
          await this.init();
          
          console.log('Worker 池已重建完成');
          return { success: true, message: '计算已取消，Worker 池已重建' };
          
        } catch (error) {
          console.error('取消任务过程中出现错误:', error);
          // 即使出错也要确保状态被清理
          this.workers = [];
          this.workerStates.clear();
          this.pendingTasks.clear();
          this.isInitialized = false;
          this.isCancelled = false;
          
          return { success: false, message: '取消任务时出现错误，但状态已清理', error: error.message };
        }
      }
      
      // 销毁 Worker 池
      destroy() {
        console.log('销毁 Worker 池');
        
        // 如果有待解决的 Promise，拒绝它
        if (this.taskReject) {
          this.taskReject(new Error('Worker 池已销毁'));
          this.taskResolve = null;
          this.taskReject = null;
        }
        
        // 终止所有 Worker
        this.workers.forEach((worker, index) => {
          console.log(`销毁 Worker ${index}`);
          worker.terminate();
        });
        
        // 清理所有状态
        this.workers = [];
        this.workerStates.clear();
        this.pendingTasks.clear();
        this.taskQueue = [];
        this.currentTaskIndex = 0;
        this.totalTasks = 0;
        this.completedTasks = 0;
        this.allResults = [];
        this.taskId = 0;
        this.globalProgressCallback = null;
        this.dynamicPruningCallback = null;
        this.isInitialized = false;
        this.isCancelled = false;
        
        console.log('Worker 池已完全销毁');
      }
    }

    // 导出 WorkerPool 类
    window.WorkerPool = WorkerPool;
  </script>
  
  <script type="module">
    const MAX = 9;
    let SIZE = 9;

    // Shapes copied from current game.py item_sharp
    const ITEM_SHAPES = [
      [[1, 0], [1, 0], [1, 0], [1, 1]],
      [[0, 1], [0, 1], [1, 1], [0, 1]],
      [[0, 0, 0, 1], [1, 1, 1, 1]],
      [[1, 1, 1, 1], [0, 1, 0, 0]],
      [[1, 1, 1], [1, 0, 0]],
      [[0, 1, 1], [1, 1, 0]],
      [[1, 1], [1, 1]],
      [[1, 1], [1, 0]],
      [[1], [1], [1]],
      [[1, 1, 1]],
      [[1], [1]],
      [[1]]
    ];

    let counts = ITEM_SHAPES.map(_ => 0);
    let pkg = Array.from({ length: SIZE }, (_, i) => Array.from({ length: SIZE }, (_, j) => i >= 2 && i <= 6 && j >= 3 && j <= 5 ? 'o' : 'x'));

    // Persist/restore state -------------------------------------------------
    const LS_COUNTS = 'packing_counts_v1';
    const LS_PKG = 'packing_pkg_v1';
    const LS_RESULTS = 'packing_results_v1';
    
    function saveState() {
      try {
        localStorage.setItem(LS_COUNTS, JSON.stringify(counts));
        localStorage.setItem(LS_PKG, JSON.stringify(pkg));
      } catch (e) { /* ignore quota errors */ }
    }
    
    function saveResults(solutions, selectedIndex = 0) {
      try {
        const resultsData = {
          solutions: solutions,
          selectedIndex: selectedIndex,
          timestamp: Date.now()
        };
        localStorage.setItem(LS_RESULTS, JSON.stringify(resultsData));
      } catch (e) { /* ignore quota errors */ }
    }
    
    function loadState() {
      try {
        const c = JSON.parse(localStorage.getItem(LS_COUNTS) || 'null');
        const p = JSON.parse(localStorage.getItem(LS_PKG) || 'null');
        if (Array.isArray(c) && c.length === ITEM_SHAPES.length && c.every(n => Number.isInteger(n) && n >= 0)) {
          counts = c.slice();
        }
        if (Array.isArray(p) && p.length === SIZE && p.every(r => Array.isArray(r) && r.length === SIZE)) {
          pkg = p.map(r => r.map(v => (v === 'x' ? 'x' : 'o')));
        }
      } catch (e) { /* ignore parse errors */ }
    }
    
    function loadResults() {
      try {
        const resultsData = JSON.parse(localStorage.getItem(LS_RESULTS) || 'null');
        if (resultsData && Array.isArray(resultsData.solutions) && resultsData.solutions.length > 0) {
          return resultsData;
        }
      } catch (e) { /* ignore parse errors */ }
      return null;
    }

    const gridEl = document.getElementById('grid');
    const visEl = document.getElementById('vis');
    const utilEl = document.getElementById('util');
    const shapesEl = document.getElementById('shapes');
    const clearBtn = document.getElementById('clear');
    const fillBtn = document.getElementById('fill');
    const clearCountsBtn = document.getElementById('clearCounts');
    const calculateBtn = document.getElementById('calculate');
    const selectionOverlay = document.getElementById('selectionOverlay');

    clearBtn.onclick = () => {
      pkg = Array.from({ length: SIZE }, (_, i) => Array.from({ length: SIZE }, (_, j) => i >= 2 && i <= 6 && j >= 3 && j <= 5 ? 'o' : 'x'));
      renderGrid();
      saveState();
    };
    fillBtn.onclick = () => {
      pkg = Array.from({ length: SIZE }, () => Array.from({ length: SIZE }, () => 'o'));
      renderGrid();
      saveState();
    };
    clearCountsBtn.onclick = () => {
      counts = counts.map(() => 0);
      document.querySelectorAll('#shapes input[type="number"]').forEach(inp => inp.value = '0');
      saveState();
    };
    calculateBtn.onclick = () => {
      requestSolve();
    };

    // 拖动选择相关变量
    let isDragging = false;
    let isMouseDown = false;
    let dragStartCell = null;
    let dragCurrentCell = null;
    let hasMoved = false; // 标记是否真正发生了拖动

    // 获取触摸或鼠标事件的坐标
    function getEventCoordinates(e) {
      if (e.touches && e.touches.length > 0) {
        return { x: e.touches[0].clientX, y: e.touches[0].clientY };
      }
      return { x: e.clientX, y: e.clientY };
    }

    // 根据坐标获取对应的网格单元格
    function getCellFromCoordinates(x, y) {
      const element = document.elementFromPoint(x, y);
      if (element && element.classList.contains('cell') && element.dataset.row !== undefined) {
        return {
          row: parseInt(element.dataset.row),
          col: parseInt(element.dataset.col),
          element: element
        };
      }
      return null;
    }

    function renderGrid() {
      gridEl.innerHTML = '';
      gridEl.style.gridTemplateColumns = `repeat(${SIZE}, 30px)`;
      
      for (let r = 0; r < SIZE; r++) {
        for (let c = 0; c < SIZE; c++) {
          const div = document.createElement('div');
          const v = pkg[r][c];
          div.className = 'cell ' + (v === 'x' ? 'block' : 'free');
          div.textContent = v === 'x' ? 'x' : '';
          div.dataset.row = r;
          div.dataset.col = c;
          
          // 单击切换功能
          div.onclick = (e) => {
            // 只有在没有发生拖动的情况下才执行单击切换
            if (!hasMoved) {
              pkg[r][c] = pkg[r][c] === 'x' ? 'o' : 'x';
              renderGrid();
              saveState();
            }
          };
          
          // 鼠标按下事件
          div.onmousedown = (e) => {
            e.preventDefault();
            startDrag(r, c);
          };
          
          // 触摸开始事件
          div.ontouchstart = (e) => {
            e.preventDefault();
            startDrag(r, c);
          };
          
          // 触摸结束事件 - 处理单击切换
          div.ontouchend = (e) => {
            e.preventDefault();
            // 如果没有发生拖动，执行单击切换
            if (!hasMoved && !isDragging) {
              pkg[r][c] = pkg[r][c] === 'x' ? 'o' : 'x';
              renderGrid();
              saveState();
            }
          };
          
          // 鼠标进入事件（用于拖动过程中）
          div.onmouseenter = () => {
            if (isMouseDown) {
              updateDragToCell(r, c);
            }
          };
          
          gridEl.appendChild(div);
        }
      }
      
      // 全局鼠标释放事件
      document.onmouseup = () => {
        endDrag();
      };
      
      // 全局触摸结束事件
      document.ontouchend = () => {
        endDrag();
      };
      
      // 全局触摸移动事件（用于拖动过程中）
      document.ontouchmove = (e) => {
        if (isMouseDown) {
          e.preventDefault();
          const coords = getEventCoordinates(e);
          const cellInfo = getCellFromCoordinates(coords.x, coords.y);
          if (cellInfo) {
            updateDragToCell(cellInfo.row, cellInfo.col);
          }
        }
      };
    }

    // 开始拖动
    function startDrag(row, col) {
      isMouseDown = true;
      hasMoved = false;
      dragStartCell = { row, col };
      dragCurrentCell = { row, col };
    }

    // 更新拖动到指定单元格
    function updateDragToCell(row, col) {
      // 检查是否真正移动到了不同的格子
      if (!dragCurrentCell || dragCurrentCell.row !== row || dragCurrentCell.col !== col) {
        if (!isDragging) {
          // 第一次移动，开始拖动模式
          isDragging = true;
          hasMoved = true;
          updateSelectionOverlay();
        }
        dragCurrentCell = { row, col };
        updateSelectionOverlay();
      }
    }

    // 结束拖动
    function endDrag() {
      if (isDragging && hasMoved) {
        applySelection();
      }
      
      // 重置所有状态
      isDragging = false;
      isMouseDown = false;
      dragStartCell = null;
      dragCurrentCell = null;
      selectionOverlay.style.display = 'none';
      
      // 延迟重置hasMoved，让click事件能够正确判断
      setTimeout(() => {
        hasMoved = false;
      }, 10);
    }

    // 更新选择遮罩层
    function updateSelectionOverlay() {
      if (!isDragging || !dragStartCell || !dragCurrentCell) return;
      
      const cellSize = 30; // 包括边框的格子大小
      const gap = 6; // 网格间距
      
      const startRow = Math.min(dragStartCell.row, dragCurrentCell.row);
      const endRow = Math.max(dragStartCell.row, dragCurrentCell.row);
      const startCol = Math.min(dragStartCell.col, dragCurrentCell.col);
      const endCol = Math.max(dragStartCell.col, dragCurrentCell.col);
      
      const left = startCol * cellSize + startCol * gap;
      const top = startRow * cellSize + startRow * gap;
      const width = (endCol - startCol + 1) * cellSize + (endCol - startCol) * gap;
      const height = (endRow - startRow + 1) * cellSize + (endRow - startRow) * gap;
      
      selectionOverlay.style.left = left + 'px';
      selectionOverlay.style.top = top + 'px';
      selectionOverlay.style.width = width + 'px';
      selectionOverlay.style.height = height + 'px';
      selectionOverlay.style.display = 'block';
    }

    // 应用选择区域
    function applySelection() {
      if (!dragStartCell || !dragCurrentCell) return;
      
      const startRow = Math.min(dragStartCell.row, dragCurrentCell.row);
      const endRow = Math.max(dragStartCell.row, dragCurrentCell.row);
      const startCol = Math.min(dragStartCell.col, dragCurrentCell.col);
      const endCol = Math.max(dragStartCell.col, dragCurrentCell.col);
      
      // 将选择区域内的所有格子设置为可用
      for (let r = startRow; r <= endRow; r++) {
        for (let c = startCol; c <= endCol; c++) {
          pkg[r][c] = 'o';
        }
      }
      
      renderGrid();
      saveState();
    }

    function renderShapes() {
      shapesEl.innerHTML = '';
      ITEM_SHAPES.forEach((s, idx) => {
        const row = document.createElement('div');
        row.className = 'row';

        const label = document.createElement('div');
        label.textContent = `${String.fromCharCode(65 + (idx % 26))}`;
        label.style.fontWeight = '600';
        label.style.fontSize = '14px';
        label.style.color = '#374151';
        label.style.minWidth = '18px';
        label.style.flexShrink = '0';

        label.style.textAlign = 'center';

        const preview = document.createElement('div');

        preview.className = 'shape';
        preview.style.gridTemplateColumns = `repeat(${s[0].length}, 10px)`;
        s.forEach(rr => rr.forEach(cc => {
          const sq = document.createElement('div');
          sq.className = 'sq ' + (cc ? 'on' : '');
          preview.appendChild(sq);
        }));

        const input = document.createElement('input');
        input.type = 'number';
        input.min = '0';
        input.value = counts[idx];
        input.style.width = '60px';
        input.style.minWidth = '50px';
        input.style.maxWidth = '70px';
        input.style.textAlign = 'center';
        input.style.fontWeight = '500';
        input.style.flexShrink = '0'; /* 防止输入框被过度压缩 */

        input.oninput = () => {
          counts[idx] = Math.max(0, parseInt(input.value || '0', 10));
          saveState();
        };


        row.appendChild(label);
        row.appendChild(preview);
        row.appendChild(input);
        shapesEl.appendChild(row);
      });
    }

    function area(shape) { return shape.flat().reduce((a, b) => a + (b ? 1 : 0), 0); }

    // Solver (ported to JS) ---------------------------------------------
    function computeFreeCells(grid) {
      let n = 0; for (const row of grid) for (const c of row) if (c === 'o') n++; return n;
    }
    function countFilled(grid) {
      let n = 0; for (const row of grid) for (const c of row) if (Array.isArray(c)) n++; return n;
    }
    function deriveCountsFromGrid(grid, shapesLen) {
      // Marks are ['i', idx, k]; count how many marks per idx
      const counts = Array(shapesLen).fill(0);
      for (const row of grid) {
        for (const c of row) {
          if (Array.isArray(c) && c[0] === 'i') counts[c[1]] += 1;
        }
      }
      // Each item contributes area equal to item shape area; to get piece counts, divide by area
      return counts.map((cells, idx) => {
        const areaVal = area(ITEM_SHAPES[idx]);
        return areaVal > 0 ? Math.round(cells / areaVal) : 0;
      });
    }

    // 创建内联的 Worker 脚本
    const workerScript = `
// Worker 脚本：在独立线程中调用 WASM 求解器
let wasmSolver = null;
let isInitialized = false;

// 初始化 WASM 模块
async function initWasm() {
  if (wasmSolver) return wasmSolver;
  
  try {
    // 动态导入 WASM 模块 - 使用绝对路径
    const wasmModule = await import(self.location.origin + '/pkg/packing_solver.js');
    await wasmModule.default();
    wasmSolver = new wasmModule.WasmPackingSolver();
    isInitialized = true;
    // console.log('Worker WASM 求解器初始化成功');
    return wasmSolver;
  } catch (error) {
    console.error('Worker WASM 初始化失败:', error);
    throw error;
  }
}

// 处理主线程发送的消息
self.onmessage = async function(e) {
  const { type, data, taskId } = e.data;
  
  try {
    switch (type) {
      case 'init':
        // 初始化 WASM 模块
        await initWasm();
        self.postMessage({
          type: 'init_complete',
          taskId,
          success: true
        });
        break;
        
      case 'solve_single': {
        // 处理单个组合任务
        if (!isInitialized) {
          await initWasm();
        }
        
        const { combination, grid: singleGrid, shapes: singleShapes, originalIndex } = data;
        
        try {
          // 重置取消标志
          wasmSolver.set_cancel(false);
          
          // 直接调用 WASM 求解器，传递独立参数
          const result = wasmSolver.solve_combination(
            singleGrid,
            singleShapes, 
            combination,
            originalIndex
          );
          
          const taskResult = {
            bestFilled: result.best_filled,
            solutions: result.solutions,
            combinationIndex: result.combination_index,
            counts: result.counts,
            cancelled: result.cancelled
          };
          
          // 发送单个任务完成结果
          self.postMessage({
            type: 'single_task_complete',
            taskId,
            results: [taskResult]
          });
          
        } catch (error) {
          console.error(\`Worker 求解组合 \${originalIndex} 时出错:\`, error);
          
          const errorResult = {
            bestFilled: -1,
            solutions: [],
            combinationIndex: originalIndex,
            counts: combination,
            cancelled: false,
            error: error.message
          };
          
          self.postMessage({
            type: 'single_task_complete',
            taskId,
            results: [errorResult]
          });
        }
        break;
      }
      case 'cancel':
        // 取消当前计算
        if (wasmSolver) {
          wasmSolver.set_cancel(true);
        }
        self.postMessage({
          type: 'cancel_complete',
          taskId
        });
        break;
        
      default:
        console.warn('Worker 收到未知消息类型:', type);
    }
  } catch (error) {
    console.error('Worker 处理消息时出错:', error);
    self.postMessage({
      type: 'error',
      taskId,
      error: error.message
    });
  }
};
    `;

    // 创建 Blob URL 用于 Worker
    const workerBlob = new Blob([workerScript], { type: 'application/javascript' });
    const workerUrl = URL.createObjectURL(workerBlob);

    // 多 Worker WASM 架构
    let workerPool = null;
    let currentSolveId = 0;
    const MAX_WORKERS = navigator.hardwareConcurrency || 1; // 使用CPU核数，默认1个
    let isCalculating = false; // 标记是否正在计算
    let currentCalculationPromise = null; // 当前计算的Promise，用于取消
    let workerPoolInitPromise = null; // Worker 池初始化的 Promise
    
    // 初始化 Worker 池
    async function initWorkerPool() {
      if (workerPool) return workerPool;
      
      // 如果已经在初始化中，返回同一个 Promise
      if (workerPoolInitPromise) {
        return workerPoolInitPromise;
      }
      
      workerPoolInitPromise = (async () => {
        try {
          workerPool = new WorkerPool(workerUrl, MAX_WORKERS);
          await workerPool.init();
          console.log(`Worker 池初始化成功，使用 ${MAX_WORKERS} 个 Worker`);
          return workerPool;
        } catch (error) {
          console.error('Worker 池初始化失败:', error);
          workerPoolInitPromise = null; // 重置，允许重试
          throw error;
        }
      })();
      
      return workerPoolInitPromise;
    }
    
    // 第一阶段：生成所有饱和的物品组合（无法再添加任何物品的组合）
    function generateValidCombinations(shapes, maxCounts, freeArea) {
      const validCombinations = [];
      
      // 预计算每个物品的面积
      const shapeAreas = shapes.map(shape => area(shape));
      
      function isSaturated(combination, currentArea) {
        // 检查是否还能添加任何物品
        for (let i = 0; i < shapes.length; i++) {
          if (combination[i] < maxCounts[i] && currentArea + shapeAreas[i] <= freeArea) {
            return false; // 还能添加第i种物品
          }
        }
        return true; // 无法再添加任何物品，组合已饱和
      }
      
      function backtrack(index, currentCombination, currentArea) {
        if (currentArea > freeArea) return; // 剪枝：面积超限
        
        if (index === shapes.length) {
          if (currentArea > 0 && isSaturated(currentCombination, currentArea)) {
            // 只保留饱和的组合（无法再添加任何物品）
            validCombinations.push([...currentCombination]);
          }
          return;
        }
        
        const shapeArea = shapeAreas[index];
        const maxPossible = Math.floor((freeArea - currentArea) / shapeArea);
        const actualMax = Math.min(maxCounts[index], maxPossible);
        
        for (let count = 0; count <= actualMax; count++) {
          currentCombination[index] = count;
          backtrack(index + 1, currentCombination, currentArea + count * shapeArea);
        }
      }
      
      backtrack(0, new Array(shapes.length).fill(0), 0);
      return validCombinations;
    }
    
    // Worker 池管理
    async function ensureWorkerPoolReady() {
      if (!workerPool) {
        await initWorkerPool();
      }
      console.log('Worker 池已准备就绪');
    }
    
    // 取消 Worker 计算
    async function cancelWorkerCalculation() {
      if (workerPool) {
        try {
          const result = await workerPool.cancelAll();
          if (result.success) {
            console.log('Worker 计算已取消:', result.message);
          } else {
            console.warn('取消 Worker 计算时出现问题:', result.message);
            if (result.error) {
              console.warn('错误详情:', result.error);
            }
          }
        } catch (error) {
          console.error('取消 Worker 计算时发生异常:', error);
          // 即使出现异常，也不向上抛出，保持优雅处理
        }
      }
    }
    
    // 辅助函数：检查组合A是否是组合B的子集
    function isSubset(smaller, larger) {
      return smaller.every((count, idx) => count <= larger[idx]);
    }
    
    // 辅助函数：计算组合的总面积
    function getCombinationArea(combination, shapes) {
      return combination.reduce((total, count, idx) => {
        return total + count * area(shapes[idx]);
      }, 0);
    }
    
    // 新的多 Worker 并行求解架构
    async function solveWithNewArchitecture(grid, shapes, counts, progressCallback, cancelToken) {
      // 记录求解开始时间
      const solveStartTime = performance.now();
      
      const freeArea = computeFreeCells(grid);
      
      // 检查是否已取消
      if (cancelToken && cancelToken.cancelled) {
        return { bestFilled: 0, solutions: [] };
      }
      
      // 确保 Worker 池已准备就绪
      await ensureWorkerPoolReady();
      
      // 第一阶段：生成所有有效组合
      console.log('第一阶段：生成有效物品组合...');
      const validCombinations = generateValidCombinations(shapes, counts, freeArea);
      console.log(`找到 ${validCombinations.length} 个有效组合`);
      
      if (validCombinations.length === 0) {
        return { bestFilled: 0, solutions: [] };
      }
      
      // 再次检查是否已取消
      if (cancelToken && cancelToken.cancelled) {
        return { bestFilled: 0, solutions: [] };
      }
      
      // 按面积从大到小排序组合，优先计算大面积组合
      validCombinations.sort((a, b) => {
        const areaA = getCombinationArea(a, shapes);
        const areaB = getCombinationArea(b, shapes);
        return areaB - areaA;
      });
      
      console.log(`使用多 Worker 并行计算（Worker 数量：${MAX_WORKERS}）`);
      
      // 第二阶段：使用多 Worker 并行计算每个组合的最优放置
      console.log('第二阶段：多 Worker 动态剪枝并行计算最优放置方案...');
      const solveId = ++currentSolveId;
      
      // 用于跟踪当前最佳组合，实现动态剪枝
      let currentBestCombination = null;
      let currentBestFilled = -1;
      let totalSkippedCount = 0;
      
      // 创建待处理任务队列（不进行预剪枝）
      const allCombinations = validCombinations.map((combination, index) => ({
        combination,
        originalIndex: index
      }));
      
      console.log(`动态任务分配：总组合 ${validCombinations.length}，启用实时动态剪枝`);
      
      // 动态进度回调
      const dynamicProgressCallback = (progress) => {
        if (progressCallback) {
          progressCallback(progress);
        }
      };
      
      // 动态剪枝回调函数
      const dynamicPruningCallback = (newResults) => {
        let prunedCount = 0;
        
        // 更新全局最优解
        for (const result of newResults) {
          if (result.bestFilled > currentBestFilled) {
            const oldBestFilled = currentBestFilled;
            currentBestFilled = result.bestFilled;
            currentBestCombination = result.counts;
            console.log(`🎯 实时更新全局最优解：填充数 ${oldBestFilled} → ${currentBestFilled}`);
          }
        }
        
        // 对剩余任务队列进行剪枝
        if (currentBestFilled > 0 && currentBestCombination) {
          const originalQueueLength = workerPool.taskQueue.length;
          const remainingTasks = [];
          
          for (let i = workerPool.currentTaskIndex; i < workerPool.taskQueue.length; i++) {
            const task = workerPool.taskQueue[i];
            const combination = task.combination;
            let shouldSkip = false;
            
            // 剪枝策略1：子集剪枝
            if (isSubset(combination, currentBestCombination) && 
                !combination.every((c, idx) => c === currentBestCombination[idx])) {
              shouldSkip = true;
            }
            
            // 剪枝策略2：面积剪枝
            if (!shouldSkip) {
              const theoreticalMaxArea = getCombinationArea(combination, shapes);
              if (theoreticalMaxArea < currentBestFilled) {
                shouldSkip = true;
              }
            }
            
            if (!shouldSkip) {
              remainingTasks.push(task);
            } else {
              prunedCount++;
            }
          }
          
          // 更新任务队列
          const newQueue = workerPool.taskQueue.slice(0, workerPool.currentTaskIndex).concat(remainingTasks);
          workerPool.taskQueue = newQueue;
          
          totalSkippedCount += prunedCount;
          
          if (prunedCount > 0) {
            console.log(`🔥 实时剪枝：移除 ${prunedCount} 个任务，剩余 ${remainingTasks.length} 个任务`);
          }
        }
        
        return prunedCount;
      };
      
      // 使用动态任务分配处理所有组合，启用动态剪枝
      const allResults = await workerPool.solveDynamic(
        allCombinations,
        grid,
        shapes,
        dynamicProgressCallback,
        dynamicPruningCallback
      );
      
      // 检查是否已取消
      if (cancelToken && cancelToken.cancelled) {
        return { bestFilled: 0, solutions: [] };
      }
      
      // 最终更新全局最优解（确保没有遗漏）
      for (const result of allResults) {
        if (result.bestFilled > currentBestFilled) {
          const oldBestFilled = currentBestFilled;
          currentBestFilled = result.bestFilled;
          currentBestCombination = result.counts;
          console.log(`🎯 最终更新全局最优解：填充数 ${oldBestFilled} → ${currentBestFilled}`);
        }
      }
      
      const actualCalculated = allResults.length;
      const pruningEfficiency = validCombinations.length > 0 ? (totalSkippedCount / validCombinations.length * 100).toFixed(1) : '0.0';
      console.log(`📊 动态剪枝统计：总组合 ${validCombinations.length}，动态跳过 ${totalSkippedCount} (${pruningEfficiency}%)，实际计算 ${actualCalculated}`);
      
      // 第三阶段：汇总最优结果
      console.log('第三阶段：汇总最优结果...');
      const successfulResults = allResults
        .filter(r => r.solutions && r.solutions.length > 0 && !r.cancelled && !r.error);
      
      const cancelledResults = allResults
        .filter(r => r.cancelled)
        .length;
      
      const errorResults = allResults
        .filter(r => r.error)
        .length;
      
      console.log(`📊 任务统计：成功 ${successfulResults.length}，取消 ${cancelledResults}，错误 ${errorResults}，总计 ${allResults.length}`);
      
      if (successfulResults.length === 0) {
        return { bestFilled: 0, solutions: [] };
      }
      
      // 找到全局最优填充数
      const globalBestFilled = Math.max(...successfulResults.map(r => r.bestFilled));
      
      // 解压缩函数（在主线程中）
      function decompressGridInMain(compressed, originalGrid) {
        const grid = originalGrid.map(r => r.slice());
        for (const p of compressed.placements) {
          grid[p.r][p.c] = ['i', p.idx, p.inst];
        }
        return grid;
      }
      
      // 收集所有最优解并解压缩
      const allBestSolutions = [];
      const solutionKeys = new Set(); // 用于主线程最终去重
      
      for (const result of successfulResults) {
        if (result.bestFilled === globalBestFilled) {
          for (const solution of result.solutions) {
            // 计算解决方案的唯一键
            const usedCounts = Array(ITEM_SHAPES.length).fill(0);
            const instanceCounts = new Map();
            
            for (const p of solution.compressed.placements) {
              const key = `${p.idx}_${p.inst}`;
              if (!instanceCounts.has(key)) {
                instanceCounts.set(key, 0);
                usedCounts[p.idx]++;
              }
            }
            
            const solutionKey = usedCounts.join(',');
            if (!solutionKeys.has(solutionKey)) {
              solutionKeys.add(solutionKey);
              
              // 只在需要时解压缩网格
              const decompressedGrid = decompressGridInMain(solution.compressed, grid);
              
              allBestSolutions.push({
                filled: solution.filled,
                grid: decompressedGrid
              });
              
              // 限制最终解决方案数量，防止主线程内存溢出
              if (allBestSolutions.length >= 50) {
                console.log('达到解决方案数量限制，停止收集更多方案');
                break;
              }
            }
          }
        }
        
        if (allBestSolutions.length >= 50) break;
      }
      
      // 计算求解耗时
      const solveEndTime = performance.now();
      const solveDuration = (solveEndTime - solveStartTime) / 1000; // 转换为秒
      
      console.log(`最终收集到 ${allBestSolutions.length} 个不同的最优解决方案，求解耗时: ${solveDuration.toFixed(2)}秒`);
      
      return { 
        bestFilled: globalBestFilled, 
        solutions: allBestSolutions 
      };
    }



    function formatResultJSGrid(bestGrid, originalGrid) {
      const totalFree = computeFreeCells(originalGrid);
      const filled = countFilled(bestGrid);
      const util = totalFree === 0 ? 0 : filled / totalFree;
      const vis = [];
      const idGrid = [];
      for (let i = 0; i < bestGrid.length; i++) {
        const row = [];
        const idRow = [];
        for (let j = 0; j < bestGrid[0].length; j++) {
          const cell = bestGrid[i][j];
          if (cell === 'x' && originalGrid[i][j] === 'o') row.push('o');
          else if (cell === 'x' || cell === 'o') row.push(cell);
          else if (Array.isArray(cell)) {
            const idx = cell[1];
            row.push(String.fromCharCode(65 + (idx % 26)));
          } else row.push(cell);
          // id grid: store item idx and instance id if present
          if (Array.isArray(cell) && cell[0] === 'i') {
            idRow.push({ idx: cell[1], inst: cell[2] });
          } else {
            idRow.push(null);
          }
        }
        vis.push(row);
        idGrid.push(idRow);
      }
      return { util, vis, idGrid };
    }

    function renderVis(grid, idGrid) {
      const rows = grid.length, cols = grid[0]?.length || 0;
      visEl.style.gridTemplateColumns = `repeat(${cols}, 24px)`;
      visEl.innerHTML = '';
      // Build high-contrast colors for instances and ensure adjacent instances differ strongly
      function keyOf(info) { return info ? `${info.idx}#${info.inst}` : '' }
      function listInstances() {
        const set = new Set();
        for (let r = 0; r < rows; r++) for (let c = 0; c < cols; c++) {
          const info = idGrid ? idGrid[r][c] : null;
          if (info) set.add(keyOf(info));
        }
        return Array.from(set);
      }
      function buildAdj() {
        const adj = new Map();
        const add = (a, b) => { if (!adj.has(a)) adj.set(a, new Set()); if (!adj.has(b)) adj.set(b, new Set()); if (a !== b) { adj.get(a).add(b); adj.get(b).add(a); } };
        for (let r = 0; r < rows; r++) for (let c = 0; c < cols; c++) {
          const a = idGrid ? idGrid[r][c] : null; if (!a) continue;
          const ka = keyOf(a);
          if (r + 1 < rows) { const b = idGrid[r + 1][c]; if (b && keyOf(b) !== ka) add(ka, keyOf(b)); }
          if (c + 1 < cols) { const b = idGrid[r][c + 1]; if (b && keyOf(b) !== ka) add(ka, keyOf(b)); }
        }
        return adj;
      }
      function generatePalette() {
        const hs = []; for (let h = 0; h < 360; h += 30) hs.push(h);
        const palette = [];
        const sats = [75, 85];
        const lights = [45, 55];
        for (const h of hs) {
          for (const s of sats) { for (const l of lights) { palette.push({ h, s, l }); } }
        }
        return palette;
      }
      function hueDist(a, b) {
        const d = Math.abs(a - b) % 360; return Math.min(d, 360 - d);
      }
      function colorDistance(c1, c2) {
        if (!c1 || !c2) return 360;
        return hueDist(c1.h, c2.h) + Math.abs((c1.l || 0) - (c2.l || 0)) * 0.5 + Math.abs((c1.s || 0) - (c2.s || 0)) * 0.2;
      }
      function toCss(c) { return `hsl(${c.h}deg ${c.s}% ${c.l}%)`; }
      function darker(c, dl = 15) { return { h: c.h, s: c.s, l: Math.max(10, c.l - dl) }; }
      function textColor(c) { return (c.l < 50) ? '#ffffff' : '#111827'; }
      function assignColors(adj) {
        const nodes = listInstances();
        const palette = generatePalette();
        // order by degree desc
        const degree = new Map();
        nodes.forEach(k => degree.set(k, (adj.get(k)?.size) || 0));
        nodes.sort((a, b) => ((degree.get(b) || 0) - (degree.get(a) || 0)));
        const colorMap = new Map();
        for (const k of nodes) {
          const neighborColors = Array.from(adj.get(k) || []).map(n => colorMap.get(n)).filter(Boolean);
          let best = null, bestScore = -1;
          for (const c of palette) {
            const minDist = neighborColors.length ? Math.min(...neighborColors.map(nc => colorDistance(c, nc))) : 360;
            if (minDist > bestScore) { bestScore = minDist; best = c; }
          }
          // fallback in unlikely case
          colorMap.set(k, best || palette[0]);
        }
        return colorMap;
      }
      const adj = idGrid ? buildAdj() : new Map();
      const colorMap = idGrid ? assignColors(adj) : new Map();
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          const div = document.createElement('div');
          div.className = 'cell';
          const v = grid[r][c];
          const info = idGrid ? idGrid[r][c] : null;
          if (v === 'x') { div.classList.add('block'); div.textContent = 'x'; }
          else if (v === 'o') { div.classList.add('free'); div.textContent = ''; }
          else {
            div.classList.add('free');
            div.textContent = v;
          }
          // Fill color per item instance (no colored borders needed)
          if (info) {
            const k = keyOf(info);
            const colObj = colorMap.get(k);
            if (colObj) {
              const fill = toCss(colObj);
              div.style.backgroundColor = fill;
              div.style.color = textColor(colObj);
            }
          }
          visEl.appendChild(div);
        }
      }
    }

    function renderCountsSummary(usedCounts) {
      const summaryEl = document.getElementById('countsSummary');
      summaryEl.innerHTML = ''; // 清空内容
      
      const hasUsedItems = usedCounts.some(count => count > 0);
      if (!hasUsedItems) {
        summaryEl.textContent = '';
        return;
      }
      
      // 创建标题
      const titleSpan = document.createElement('span');
      titleSpan.textContent = '使用数量：';
      titleSpan.style.marginRight = '8px';
      summaryEl.appendChild(titleSpan);
      
      // 为每个使用的物品创建形状显示
      for (let idx = 0; idx < ITEM_SHAPES.length; idx++) {
        const provided = counts[idx] || 0; // 用户提供的数量
        if (provided <= 0) continue; // 只显示用户设置了数量的物品
        
        const used = usedCounts[idx] || 0;
        const remain = Math.max(0, provided - used);
        
        // 创建物品容器
        const itemContainer = document.createElement('span');
        itemContainer.style.display = 'inline-flex';
        itemContainer.style.alignItems = 'center'; // 垂直居中
        itemContainer.style.marginRight = '12px';
        itemContainer.style.marginBottom = '4px';
        itemContainer.style.verticalAlign = 'middle'; // 确保整个容器相对于其他内容垂直居中
        
        // 创建缩小的形状显示
        const shapeDiv = document.createElement('div');
        shapeDiv.className = 'shape';
        shapeDiv.style.display = 'inline-grid';
        shapeDiv.style.gap = '1px';
        shapeDiv.style.padding = '2px';
        shapeDiv.style.background = '#f9fafb';
        shapeDiv.style.border = '1px solid var(--border)';
        shapeDiv.style.borderRadius = '4px';
        shapeDiv.style.marginRight = '4px';

        
        const shape = ITEM_SHAPES[idx];
        shapeDiv.style.gridTemplateColumns = `repeat(${shape[0].length}, 6px)`;
        
        shape.forEach(row => {
          row.forEach(cell => {
            const sq = document.createElement('div');
            sq.style.width = '6px';
            sq.style.height = '6px';
            sq.style.border = '1px solid #cbd5e1';
            sq.style.borderRadius = '1px';
            sq.style.background = cell ? '#64748b' : '#fff';
            shapeDiv.appendChild(sq);
          });
        });
        
        // 创建数量文本
        const countText = document.createElement('span');
        countText.style.fontSize = '12px';
        countText.style.color = 'var(--muted)';
        countText.style.lineHeight = '1'; // 设置行高为1，避免额外的行间距影响对齐
        countText.textContent = remain > 0 ? `${used}(${remain})` : `${used}`;
        
        itemContainer.appendChild(shapeDiv);
        itemContainer.appendChild(countText);
        summaryEl.appendChild(itemContainer);
      }
    }

    const solutionSelect = document.getElementById('solutionSelect');
    const solutionCountEl = document.getElementById('solutionCount');
    let solveTimer = null;
    let currentSolutions = [];
    let progressTimeout = null; // 进度条显示的定时器
    
    function loadAndDisplayResults() {
      const resultsData = loadResults();
      if (!resultsData || !resultsData.solutions || resultsData.solutions.length === 0) {
        // 没有保存的结果，显示默认状态
        utilEl.innerHTML = '利用率: --';
        visEl.innerHTML = '';
        document.getElementById('countsSummary').textContent = '';
        solutionCountEl.textContent = '解法：0种';
        solutionSelect.innerHTML = '';
        // 只隐藏选择下拉框，保留解法数量显示
        solutionSelect.parentElement.style.display = 'none';
        // 展示空格子
        renderVis(Array.from({ length: SIZE }, () => Array.from({ length: SIZE }, () => 'o')));
        return;
      }
      
      const { solutions, selectedIndex } = resultsData;
      currentSolutions = solutions;
      const totalFree = computeFreeCells(pkg);
      
      // 显示选择下拉框
      solutionSelect.parentElement.style.display = 'inline';
      
      // 重建选项
      solutionSelect.innerHTML = '';
      solutionCountEl.textContent = `解法：${solutions.length}种`;
      
      solutions.forEach((s, i) => {
        const opt = document.createElement('option');
        opt.value = String(i);
        opt.textContent = `方案 ${i + 1}`;
        solutionSelect.appendChild(opt);
        opt.dataset.counts = JSON.stringify(s.counts);
      });
      
      // 选择之前保存的方案
      const validIndex = Math.min(selectedIndex || 0, solutions.length - 1);
      solutionSelect.value = String(validIndex);
      
      // 显示选中的方案
      const selectedSolution = solutions[validIndex];
      const { util, vis, idGrid } = formatResultJSGrid(selectedSolution.grid, pkg);
      utilEl.innerHTML = `利用率: <strong>${(util * 100).toFixed(2)}%</strong>`;
      renderVis(vis, idGrid);
      
      const opt = solutionSelect.options[validIndex];
      if (opt && opt.dataset.counts) {
        renderCountsSummary(JSON.parse(opt.dataset.counts));
      }
    }
    
    // 清空当前显示的结果
    function clearCurrentResults() {
      utilEl.innerHTML = '利用率: --';
      visEl.innerHTML = '';
      document.getElementById('countsSummary').textContent = '';
      solutionCountEl.textContent = '解法：0种';
      solutionSelect.innerHTML = '';
      currentSolutions = [];
      // 只隐藏选择下拉框，保留解法数量显示
      solutionSelect.parentElement.style.display = 'none';
      // 显示空的网格
      renderVis(Array.from({ length: SIZE }, () => Array.from({ length: SIZE }, () => 'o')));
    }
    
    // 更新按钮状态
    function updateCalculateButton(calculating) {
      const calculateBtn = document.getElementById('calculate');
      if (calculating) {
        calculateBtn.textContent = '取消计算';
        calculateBtn.classList.add('cancel');
      } else {
        calculateBtn.textContent = '计算结果';
        calculateBtn.classList.remove('cancel');
      }
    }
    
    // 取消当前计算
    function cancelCalculation() {
      if (!isCalculating) return;
      
      console.log('用户取消计算');
      isCalculating = false;
      
      // 清除进度条显示的定时器
      if (progressTimeout) {
        clearTimeout(progressTimeout);
        progressTimeout = null;
      }
      
      // 设置取消标记
      if (currentCalculationPromise && currentCalculationPromise.cancelToken) {
        currentCalculationPromise.cancelToken.cancelled = true;
      }
      
      // 取消 Worker 计算
      cancelWorkerCalculation();
      
      // 隐藏进度条和遮罩
      const progressContainer = document.getElementById('progressContainer');
      const resultOverlay = document.getElementById('resultOverlay');
      progressContainer.style.display = 'none';
      resultOverlay.classList.remove('show');
      
      // 恢复按钮状态
      updateCalculateButton(false);
      
      console.log('计算已取消');
    }
    
    function requestSolve() {
      // 如果正在计算，则取消计算
      if (isCalculating) {
        cancelCalculation();
        return;
      }
      
      // 检查是否有物品数量设置
      const hasItems = counts.some(count => count > 0);
      if (!hasItems) {
        // 没有设置任何物品数量，直接显示空结果
        clearCurrentResults();
        utilEl.innerHTML = '利用率: <strong>0.00%</strong>';
        solutionCountEl.textContent = '解法：0种';
        saveResults([]);
        return;
      }
      
      clearTimeout(solveTimer);
      solveTimer = setTimeout(() => {
        // 标记开始计算
        isCalculating = true;
        
        // 清空当前结果
        clearCurrentResults();
        
        // 更新按钮状态
        updateCalculateButton(true);
        
        // 获取进度条和遮罩元素
        const progressContainer = document.getElementById('progressContainer');
        const progressFill = document.getElementById('progressFill');
        const progressText = document.getElementById('progressText');
        const resultOverlay = document.getElementById('resultOverlay');
        
        // 初始化进度条状态（但不显示）
        progressFill.style.width = '0%';
        progressText.textContent = '0%';
        
        // 进度回调函数，添加防抖和平滑处理
        let lastDisplayedProgress = 0;
        const updateProgress = (progress) => {
          const roundedProgress = Math.round(progress);
          // 只有当进度真正增加时才更新显示，避免反复横跳
          if (roundedProgress > lastDisplayedProgress) {
            lastDisplayedProgress = roundedProgress;
            progressFill.style.width = `${roundedProgress}%`;
            progressText.textContent = `${roundedProgress}%`;
          }
        };
        
        // 延迟300毫秒显示进度条和遮罩
        progressTimeout = setTimeout(() => {
          if (isCalculating) {
            progressContainer.style.display = 'flex';
            resultOverlay.classList.add('show');
          }
        }, 300);
        
        // 立即开始计算
        setTimeout(async () => {
          try {
            // 创建取消令牌
            const cancelToken = { cancelled: false };
            
            // 创建计算Promise并保存引用
            currentCalculationPromise = solveWithNewArchitecture(pkg, ITEM_SHAPES, counts, updateProgress, cancelToken);
            currentCalculationPromise.cancelToken = cancelToken;
            
            // 使用新的三阶段架构进行求解
            const { bestFilled, solutions } = await currentCalculationPromise;
            
            // 计算完成，取消进度条显示的定时器
            clearTimeout(progressTimeout);
            
            // 计算完成后立即显示100%
            updateProgress(100);
            
            // 处理结果（solutions已经包含counts信息，无需重新推导）
            const totalFree = computeFreeCells(pkg);
            const seen = new Map(); // key -> {filled, grid, counts}
            const unique = [];
            
            for (const s of solutions) {
              const countsToUse = deriveCountsFromGrid(s.grid, ITEM_SHAPES.length);
              const key = countsToUse.join(',');
              if (!seen.has(key)) {
                const entry = { ...s, counts: countsToUse };
                seen.set(key, entry);
                unique.push(entry);
              }
            }
            
            currentSolutions = unique;
            
            // 构建选项
            solutionSelect.innerHTML = '';
            if (unique.length === 0) {
              utilEl.innerHTML = '利用率: --';
              visEl.innerHTML = '';
              document.getElementById('countsSummary').textContent = '';
              solutionCountEl.textContent = '解法：0种';
              // 只隐藏选择下拉框，保留解法数量显示
              solutionSelect.parentElement.style.display = 'none';
              // 展示空格子
              renderVis(Array.from({ length: SIZE }, () => Array.from({ length: SIZE }, () => 'o')));
              // 保存空结果
              saveResults([]);
              return;
            }
            
            // 显示选择下拉框
            solutionSelect.parentElement.style.display = 'inline';
            
            solutionCountEl.textContent = `解法：${unique.length}种`;
            unique.forEach((s, i) => {
              const util = totalFree === 0 ? 0 : s.filled / totalFree;
              const opt = document.createElement('option');
              opt.value = String(i);
              opt.textContent = `方案 ${i + 1}`;
              solutionSelect.appendChild(opt);
              // Store counts for later
              opt.dataset.counts = JSON.stringify(s.counts);
            });
            
            // 默认选择第一个解决方案
            solutionSelect.value = '0';
            const first = unique[0];
            const { util, vis, idGrid } = formatResultJSGrid(first.grid, pkg);
            utilEl.innerHTML = `利用率: <strong>${(util * 100).toFixed(2)}%</strong>`;
            renderVis(vis, idGrid);
            renderCountsSummary(JSON.parse(solutionSelect.options[0].dataset.counts));
            
            // 保存计算结果
            saveResults(unique, 0);
            
            // 隐藏进度条和遮罩
            progressContainer.style.display = 'none';
            resultOverlay.classList.remove('show');
            
          } catch (error) {
            console.error('计算过程中出现错误:', error);
            
            // 计算出错，取消进度条显示的定时器
            clearTimeout(progressTimeout);
            
            // 如果是取消操作，不显示错误信息
            if (error.message !== '计算已取消') {
              utilEl.innerHTML = '计算出错，请重试';
            }
            
            progressContainer.style.display = 'none';
            resultOverlay.classList.remove('show');
          } finally {
            // 恢复计算状态和按钮
            isCalculating = false;
            updateCalculateButton(false);
            currentCalculationPromise = null;
          }
        }, 10); // 短暂延迟让进度条显示
      }, 50);
    }

    solutionSelect.onchange = () => {
      const idx = parseInt(solutionSelect.value, 10);
      const s = currentSolutions[idx];
      const { util, vis, idGrid } = formatResultJSGrid(s.grid, pkg);
      utilEl.innerHTML = `利用率: <strong>${(util * 100).toFixed(2)}%</strong>`;
      renderVis(vis, idGrid);
      const opt = solutionSelect.options[solutionSelect.selectedIndex];
      renderCountsSummary(JSON.parse(opt.dataset.counts || '[]'));
      
      // 保存当前选中的方案索引
      if (currentSolutions.length > 0) {
        saveResults(currentSolutions, idx);
      }
    };

    async function init() {
      loadState();
      renderGrid();
      renderShapes();
      // 载入并显示上次的计算结果
      loadAndDisplayResults();
      
      // 在页面加载时就开始初始化 Worker 池
      console.log('开始初始化 Worker 池...');
      try {
        await initWorkerPool();
        console.log('Worker 池在页面加载时初始化完成');
      } catch (error) {
        console.warn('Worker 池初始化失败，将在需要时重试:', error);
      }
    }
    init();
  </script>
</body>

</html>