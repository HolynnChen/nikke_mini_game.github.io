<!doctype html>
<html>

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>9x9 èƒŒåŒ…å †ç§¯å¯è§†åŒ–</title>
  <style>
    :root {
      --bg: #f6f8fb;
      --card-bg: #ffffff;
      --text: #1f2937;
      --muted: #6b7280;
      --primary: #3b82f6;
      --primary-700: #2563eb;
      --border: #e5e7eb;
    }

    * {
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, system-ui, Segoe UI, Roboto, sans-serif;
      margin: 0;
      min-height: 100vh;
      background: linear-gradient(180deg, #eef2ff 0%, #f8fafc 100%);
      color: var(--text);
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .page {
      width: 100%;
      max-width: 1080px;
      padding: 24px;
    }

    h2 {
      text-align: center;
      margin: 0 0 6px;
      font-weight: 700;
      letter-spacing: 0.2px;
    }

    .small {
      color: var(--muted);
      font-size: 13px;
      text-align: center;
      margin-bottom: 16px;
    }

    .container {
      display: grid;
      gap: 20px;
      grid-template-columns: 1fr 400px 1fr;
      align-items: start;
    }





    .panel {
      background: var(--card-bg);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 16px;
      box-shadow: 0 6px 24px rgba(0, 0, 0, 0.06);
    }

    .panel h3 {
      margin: 0;
      font-size: 16px;
    }

    .panel-head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      margin-bottom: 12px;
      min-height: 24px;
    }

    .panel-head .button-group {
      display: flex;
      gap: 8px;
      margin-left: auto;
    }

    .panel-head .button-group button {
      padding: 6px 10px;
      font-size: 13px;
      font-weight: 500;
    }

    .grid {
      display: grid;
      gap: 6px;
      justify-content: center;
    }

    .cell {
      width: 30px;
      height: 30px;
      display: flex;
      align-items: center;
      justify-content: center;
      border: 1px solid var(--border);
      cursor: pointer;
      user-select: none;
      border-radius: 6px;
      transition: background 0.15s, transform 0.05s;
      font-weight: 600;
    }

    .cell.block {
      background: #111827;
      color: #fff;
      border-color: #111827;
    }

    .cell.free {
      background: #ffffff;
    }

    .cell.free:hover {
      background: #f3f6ff;
    }

    .cell:active {
      transform: scale(0.98);
    }

    .resultGrid .cell {
      width: 26px;
      height: 26px;
    }

    .resultGrid .cell {
      position: relative;
    }

    .row {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      background: #f8fafc;
      border-radius: 8px;
      border: 1px solid #e2e8f0;
      min-width: 0; /* å…è®¸flexé¡¹ç›®æ”¶ç¼© */
    }

    #shapes {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 8px;
      padding: 4px;
    }



    .shape {
      display: inline-grid;
      gap: 2px;
      padding: 6px;
      background: #ffffff;
      border: 1px solid #d1d5db;
      border-radius: 6px;
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
    }


    .sq {
      width: 10px;
      height: 10px;
      border: 1px solid #cbd5e1;
      border-radius: 2px;
      background: #fff;
    }

    .sq.on {
      background: #64748b;
    }

    .controls {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
      justify-content: center;
      margin-top: 12px;
    }

    select,
    input[type="number"] {
      appearance: none;
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 6px 10px;
      font-size: 14px;
      background: #fff;
      color: var(--text);
    }

    input[type="number"] {
      width: 80px;
    }

    button {
      border: 0;
      background: var(--primary);
      color: #fff;
      padding: 8px 12px;
      border-radius: 10px;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.15s, transform 0.05s;
    }

    button:hover {
      background: var(--primary-700);
    }

    button:active {
      transform: translateY(1px);
    }

    /* å–æ¶ˆæŒ‰é’®æ ·å¼ */
    button.cancel {
      background: #dc2626;
    }

    button.cancel:hover {
      background: #b91c1c;
    }

    .util {
      display: flex;
      justify-content: center;
      align-items: baseline;
      gap: 8px;
      margin: 8px 0 12px;
    }

    .util strong {
      font-size: 20px;
      color: var(--primary-700);
    }

    .solutions {
      display: flex;
      align-items: center;
      gap: 10px;
      justify-content: center;
      margin: 8px 0;
    }

    .summary {
      margin-top: 10px;
      color: var(--muted);
      font-size: 13px;
      text-align: center;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-wrap: wrap;
      line-height: 1.4;
    }


    .progress-container {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-left: auto;
      height: 100%;
    }

    .progress-bar {
      width: 80px;
      height: 6px;
      background: #e5e7eb;
      border-radius: 3px;
      overflow: hidden;
      position: relative;
    }

    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, var(--primary) 0%, var(--primary-700) 100%);
      border-radius: 3px;
      width: 0%;
      transition: width 0.2s ease-out;
    }

    .progress-text {
      font-size: 11px;
      color: var(--muted);
      font-weight: 500;
      min-width: 28px;
      text-align: right;
    }

    .footer {
      color: var(--muted);
      font-size: 12px;
      margin-top: 14px;
      text-align: center;
    }

    .result-overlay {
      position: absolute;
      top: 50px;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(255, 255, 255, 0.9);
      backdrop-filter: blur(2px);
      display: none;
      align-items: center;
      justify-content: center;
      border-radius: 0 0 12px 12px;
      z-index: 10;
    }

    .result-overlay.show {
      display: flex;
    }

    .loading-spinner {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 16px;
    }

    .spinner {
      width: 40px;
      height: 40px;
      border: 3px solid #e5e7eb;
      border-top: 3px solid var(--primary);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .loading-text {
      color: var(--muted);
      font-size: 14px;
      font-weight: 500;
    }

    /* ç¡®ä¿ç»“æœé¢æ¿æœ‰ç›¸å¯¹å®šä½ */
    .result-panel {
      position: relative;
    }

    /* æ‹–åŠ¨çŸ©å½¢é€‰æ‹©åŠŸèƒ½æ ·å¼ */
    .grid-container {
      position: relative;
      display: inline-block;
    }

    .selection-overlay {
      position: absolute;
      border: 2px dashed var(--primary);
      background: rgba(59, 130, 246, 0.1);
      pointer-events: none;
      z-index: 5;
      display: none;
    }

    .grid {
      user-select: none;
    }

    @media (max-width: 1200px) {
      .container {
        grid-template-columns: 1fr 1fr;
      }

      
      #shapes {
        grid-template-columns: repeat(2, minmax(0, 1fr)); /* åœ¨ä¸¤åˆ—å¸ƒå±€æ—¶ä¿æŒä¸¤åˆ— */
      }
      
      .row {
        gap: 10px; /* å¢åŠ é—´è· */
        padding: 8px 12px;
      }
      
      input[type="number"] {
        width: 70px !important; /* æ¢å¤è¾ƒå¤§çš„è¾“å…¥æ¡† */
      }
    }



    @media (max-width: 900px) {
      .container {
        grid-template-columns: 1fr;
      }

      #shapes {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }
      
      .row {
        gap: 12px;
        padding: 10px 14px;
      }
      
      input[type="number"] {
        width: 80px !important;
      }
    }



  </style>
</head>

<body>
  <div class="page">
    <h2>9x9 èƒŒåŒ…å †ç§¯å¯è§†åŒ–</h2>
    <div class="small">ç‚¹å‡»ç½‘æ ¼åˆ‡æ¢å¯ç”¨/ä¸å¯ç”¨(x)ã€‚è®¾ç½®å„å½¢çŠ¶æ•°é‡ï¼Œå®æ—¶è®¡ç®—å¹¶å±•ç¤ºæœ€ä¼˜å †ç§¯æ–¹æ¡ˆåŠåˆ©ç”¨ç‡ã€‚æœ€ä½³ç”¨é€”ï¼šå¸®ä½ å¡«ç¼ã€‚</div>

    <div class="container">
      <div class="panel">
        <h3>èƒŒåŒ… 9x9</h3>
        <div class="grid-container">
          <div id="grid" class="grid"></div>
          <div id="selectionOverlay" class="selection-overlay"></div>
        </div>
        <div class="controls">
          <button id="clear">é‡ç½®èƒŒåŒ…çŠ¶æ€</button>
          <button id="fill">å…¨éƒ¨å¯ç”¨</button>
        </div>
      </div>
      <div class="panel">
        <div class="panel-head">
          <h3>ç‰©ä½“æ•°é‡</h3>
          <div class="button-group">
            <button id="clearCounts">æ¸…ç©ºç‰©å“æ•°é‡</button>
            <button id="calculate">è®¡ç®—ç»“æœ</button>
          </div>
        </div>
        <div id="shapes"></div>
      </div>
      <div class="panel result-panel">
        <div class="panel-head">
          <h3>ç»“æœ</h3>
          <div class="progress-container" id="progressContainer" style="display: none;">
            <div class="progress-bar">
              <div class="progress-fill" id="progressFill"></div>
            </div>
            <span class="progress-text" id="progressText">0%</span>
          </div>
        </div>
        <div id="util" class="util">åˆ©ç”¨ç‡: --</div>
        <div class="solutions">
          <span id="solutionCount">è§£æ³•ï¼š0ç§</span>
          <label>é€‰æ‹©:
            <select id="solutionSelect"></select>
          </label>
        </div>
        <div id="vis" class="grid resultGrid"></div>
        <div id="countsSummary" class="summary"></div>
        <div class="result-overlay" id="resultOverlay">
          <div class="loading-spinner">
            <div class="spinner"></div>
            <div class="loading-text">æ­£åœ¨è®¡ç®—æœ€ä¼˜æ–¹æ¡ˆ...</div>
          </div>
        </div>
      </div>
    </div>


    <div class="footer">è¯´æ˜ï¼šç‰©ä½“ä¸å¯æ—‹è½¬ï¼›å­—æ¯è¡¨ç¤ºä¸åŒå½¢çŠ¶çš„æ‘†æ”¾ï¼›ç©ºä½™å¯ç”¨ä½ç½®æ˜¾ç¤ºä¸ºç©ºï¼Œéšœç¢æ˜¾ç¤ºä¸º xã€‚</div>
  </div>

  <script>
    // Worker æ± ç®¡ç†å™¨ - å†…è”ç‰ˆæœ¬
    class WorkerPool {
      constructor(workerScript, maxWorkers = null) {
        this.workerScript = workerScript;
        this.maxWorkers = maxWorkers || navigator.hardwareConcurrency || 4;
        this.workers = [];
        this.workerStates = new Map(); // workerId -> 'available' | 'busy' | 'initializing'
        this.isInitialized = false;
        
        // åŠ¨æ€ä»»åŠ¡åˆ†é…ç›¸å…³
        this.taskQueue = [];
        this.currentTaskIndex = 0;
        this.totalTasks = 0;
        this.completedTasks = 0;
        this.allResults = [];
        this.globalProgressCallback = null;
        this.taskResolve = null;
        this.taskReject = null;
        this.isCancelled = false;
        this.taskId = 0;
        this.pendingTasks = new Map();
      }
      // åˆå§‹åŒ– Worker æ± 
      async init() {
        if (this.isInitialized) return;
        
        console.log(`åˆå§‹åŒ– Worker æ± ï¼Œåˆ›å»º ${this.maxWorkers} ä¸ª Worker`);
        
        // åˆ›å»º Worker å®ä¾‹
        for (let i = 0; i < this.maxWorkers; i++) {
          const worker = new Worker(this.workerScript, { type: 'module' });
          worker.workerId = i;
          
          // è®¾ç½®æ¶ˆæ¯å¤„ç†å™¨
          worker.onmessage = (e) => this.handleWorkerMessage(worker, e);
          worker.onerror = (error) => this.handleWorkerError(worker, error);
          
          this.workers.push(worker);
          this.workerStates.set(i, 'initializing');
        }
        
        // åˆå§‹åŒ–æ‰€æœ‰ Worker ä¸­çš„ WASM æ¨¡å—
        const initPromises = this.workers.map(worker => {
          return new Promise((resolve, reject) => {
            const taskId = ++this.taskId;
            this.pendingTasks.set(taskId, { resolve, reject, type: 'init' });
            
            worker.postMessage({
              type: 'init',
              taskId
            });
          });
        });
        
        await Promise.all(initPromises);
        
        // å°†æ‰€æœ‰ Worker æ ‡è®°ä¸ºå¯ç”¨
        for (let i = 0; i < this.maxWorkers; i++) {
          this.workerStates.set(i, 'available');
        }
        
        this.isInitialized = true;
        console.log('Worker æ± åˆå§‹åŒ–å®Œæˆ');
      }
      
      // å¤„ç† Worker æ¶ˆæ¯
      handleWorkerMessage(worker, e) {
        const { type, taskId, ...data } = e.data;
        const task = this.pendingTasks.get(taskId);
        
        switch (type) {
          case 'init_complete':
            if (task) {
              this.pendingTasks.delete(taskId);
              if (data.success) {
                task.resolve();
              } else {
                task.reject(new Error('Worker åˆå§‹åŒ–å¤±è´¥'));
              }
            }
            break;
            
          case 'single_task_complete':
            this.handleSingleTaskComplete(worker, taskId, data);
            break;
            
          case 'cancel_complete':
            if (task) {
              this.pendingTasks.delete(taskId);
              this.setWorkerAvailable(worker);
              task.resolve();
            }
            break;
            
          case 'error':
            if (task) {
              this.pendingTasks.delete(taskId);
              this.setWorkerAvailable(worker);
              task.reject(new Error(data.error));
            }
            break;
        }
      }
      
      // å¤„ç†å•ä¸ªä»»åŠ¡å®Œæˆ
      handleSingleTaskComplete(worker, taskId, data) {
        const task = this.pendingTasks.get(taskId);
        if (!task) return;
        
        this.pendingTasks.delete(taskId);
        
        // æ”¶é›†ç»“æœ
        if (data.results && data.results.length > 0) {
          this.allResults.push(...data.results);
        }
        
        // æ›´æ–°è¿›åº¦
        this.completedTasks++;
        if (this.globalProgressCallback) {
          const progress = (this.completedTasks / this.totalTasks) * 100;
          this.globalProgressCallback(progress);
        }
        
        console.log(`Worker ${worker.workerId} å®Œæˆä»»åŠ¡ï¼Œè¿›åº¦: ${this.completedTasks}/${this.totalTasks}`);
        
        // è°ƒç”¨åŠ¨æ€å‰ªæå›è°ƒï¼ˆå¦‚æœå­˜åœ¨ï¼‰
        if (this.dynamicPruningCallback && data.results && data.results.length > 0) {
          const prunedCount = this.dynamicPruningCallback(data.results);
          if (prunedCount > 0) {
            console.log(`ğŸ”¥ åŠ¨æ€å‰ªæï¼šç§»é™¤äº† ${prunedCount} ä¸ªå¾…å¤„ç†ä»»åŠ¡`);
            // æ›´æ–°æ€»ä»»åŠ¡æ•°
            this.totalTasks -= prunedCount;
          }
        }
        
        // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰ä»»åŠ¡éƒ½å®Œæˆäº†
        if (this.completedTasks >= this.totalTasks) {
          console.log(`æ‰€æœ‰ä»»åŠ¡å®Œæˆï¼Œå…±æ”¶é›†åˆ° ${this.allResults.length} ä¸ªç»“æœ`);
          if (this.taskResolve) {
            this.taskResolve(this.allResults);
            this.taskResolve = null;
            this.taskReject = null;
          }
          this.setWorkerAvailable(worker);
          return;
        }
        
        // ä¸ºè¿™ä¸ª Worker åˆ†é…ä¸‹ä¸€ä¸ªä»»åŠ¡
        this.assignNextTask(worker);
      }
      
      // å¤„ç† Worker é”™è¯¯
      handleWorkerError(worker, error) {
        console.error(`Worker ${worker.workerId} å‡ºé”™:`, error);
        
        // å¦‚æœæ˜¯åœ¨åŠ¨æ€ä»»åŠ¡åˆ†é…è¿‡ç¨‹ä¸­å‡ºé”™ï¼Œå°è¯•åˆ†é…ä¸‹ä¸€ä¸ªä»»åŠ¡
        if (this.currentTaskIndex < this.totalTasks && !this.isCancelled) {
          // ä¸éœ€è¦å…ˆé‡Šæ”¾ Workerï¼Œç›´æ¥åˆ†é…ä¸‹ä¸€ä¸ªä»»åŠ¡
          this.assignNextTask(worker);
        } else {
          // å¦‚æœæ²¡æœ‰æ›´å¤šä»»åŠ¡ï¼Œåˆ™å°† Worker è®¾ä¸ºå¯ç”¨
          this.setWorkerAvailable(worker);
        }
      }
      
      // è®¾ç½® Worker ä¸ºå¯ç”¨çŠ¶æ€
      setWorkerAvailable(worker) {
        if (!worker || typeof worker.workerId === 'undefined') {
          console.warn('setWorkerAvailable: worker å‚æ•°æ— æ•ˆ');
          return;
        }
        
        this.workerStates.set(worker.workerId, 'available');
        // console.log(`Worker ${worker.workerId} è®¾ä¸ºå¯ç”¨çŠ¶æ€`);
      }
      
      // è®¾ç½® Worker ä¸ºå¿™ç¢ŒçŠ¶æ€
      setWorkerBusy(worker) {
        if (!worker || typeof worker.workerId === 'undefined') {
          console.warn('setWorkerBusy: worker å‚æ•°æ— æ•ˆ');
          return;
        }
        
        this.workerStates.set(worker.workerId, 'busy');
        // console.log(`Worker ${worker.workerId} è®¾ä¸ºå¿™ç¢ŒçŠ¶æ€`);
      }
      
      // æ£€æŸ¥ Worker æ˜¯å¦å¯ç”¨
      isWorkerAvailable(worker) {
        if (!worker || typeof worker.workerId === 'undefined') {
          return false;
        }
        
        return this.workerStates.get(worker.workerId) === 'available';
      }
      
      // è·å–ä¸‹ä¸€ä¸ªå¯ç”¨çš„ Worker
      getNextAvailableWorker() {
        for (const worker of this.workers) {
          if (this.isWorkerAvailable(worker)) {
            return worker;
          }
        }
        return null;
      }
      
      // è·å–å¯ç”¨ Worker æ•°é‡
      getAvailableWorkerCount() {
        let count = 0;
        for (const [workerId, state] of this.workerStates) {
          if (state === 'available') {
            count++;
          }
        }
        return count;
      }
      
      // ä¸º Worker åˆ†é…ä¸‹ä¸€ä¸ªä»»åŠ¡
      assignNextTask(worker) {
        // æ£€æŸ¥ Worker å¯¹è±¡æ˜¯å¦æœ‰æ•ˆ
        if (!worker) {
          console.error('assignNextTask: worker å‚æ•°ä¸ºç©º');
          return;
        }
        
        // ç¡®ä¿ workerId å­˜åœ¨
        if (typeof worker.workerId === 'undefined') {
          // å°è¯•ä» workers æ•°ç»„ä¸­æ‰¾åˆ°å¯¹åº”çš„ workerId
          const workerIndex = this.workers.indexOf(worker);
          if (workerIndex !== -1) {
            worker.workerId = workerIndex;
          } else {
            console.warn('assignNextTask: æ— æ³•ç¡®å®š worker IDï¼Œä½¿ç”¨é»˜è®¤å€¼');
            worker.workerId = 'unknown';
          }
        }
        
        // æ£€æŸ¥æ˜¯å¦å·²å–æ¶ˆ
        if (this.isCancelled) {
          this.setWorkerAvailable(worker);
          return;
        }
        
        // æ£€æŸ¥æ˜¯å¦è¿˜æœ‰ä»»åŠ¡
        if (this.currentTaskIndex >= this.taskQueue.length) {
          this.setWorkerAvailable(worker);
          return;
        }
        
        // è·å–ä¸‹ä¸€ä¸ªä»»åŠ¡
        const task = this.taskQueue[this.currentTaskIndex];
        this.currentTaskIndex++;
        
        // æ ‡è®° Worker ä¸ºå¿™ç¢Œ
        this.setWorkerBusy(worker);
        
        // console.log(`Worker ${worker.workerId} å¼€å§‹å¤„ç†ä»»åŠ¡ ${this.currentTaskIndex}/${this.totalTasks}`);
        
        // åˆ›å»ºä»»åŠ¡è®°å½•
        const taskId = ++this.taskId;
        this.pendingTasks.set(taskId, { 
          type: 'single_task',
          worker: worker,
          taskIndex: this.currentTaskIndex - 1
        });
        
        // å‘é€å•ä¸ªä»»åŠ¡
        worker.postMessage({
          type: 'solve_single',
          data: {
            combination: task.combination,
            grid: task.grid,
            shapes: task.shapes,
            originalIndex: task.originalIndex
          },
          taskId
        });
      }
      
      // åŠ¨æ€ä»»åŠ¡åˆ†é… - ä¸»è¦æ¥å£
      async solveDynamic(combinations, grid, shapes, progressCallback, dynamicPruningCallback) {
        if (!this.isInitialized) {
          await this.init();
        }
        
        if (combinations.length === 0) {
          return [];
        }
        
        console.log(`å¼€å§‹åŠ¨æ€ä»»åŠ¡åˆ†é…ï¼Œæ€»å…± ${combinations.length} ä¸ªç»„åˆ`);
        
        // é‡ç½®çŠ¶æ€
        this.currentTaskIndex = 0;
        this.totalTasks = combinations.length;
        this.completedTasks = 0;
        this.allResults = [];
        this.globalProgressCallback = progressCallback;
        this.dynamicPruningCallback = dynamicPruningCallback;
        this.isCancelled = false;
        
        // åˆ›å»ºä»»åŠ¡é˜Ÿåˆ—
        this.taskQueue = combinations.map((combination, index) => ({
          combination: combination.combination,
          originalIndex: combination.originalIndex,
          grid: grid,
          shapes: shapes,
          taskIndex: index
        }));
        
        return new Promise((resolve, reject) => {
          this.taskResolve = resolve;
          this.taskReject = reject;
          
          // å¯åŠ¨æ‰€æœ‰å¯ç”¨çš„ Worker
          const availableWorkerCount = this.getAvailableWorkerCount();
          const workersToStart = Math.min(availableWorkerCount, this.taskQueue.length);
          console.log(`å‡†å¤‡å¯åŠ¨ ${workersToStart} ä¸ª Workerï¼Œå¯ç”¨ Worker æ•°é‡: ${availableWorkerCount}`);
          
          let startedWorkers = 0;
          for (const worker of this.workers) {
            if (startedWorkers >= workersToStart) break;
            
            if (this.isWorkerAvailable(worker)) {
              // console.log(`å¯åŠ¨ Worker ${worker.workerId} å¤„ç†ä»»åŠ¡`);
              this.assignNextTask(worker);
              startedWorkers++;
            }
          }
          
          if (startedWorkers === 0) {
            console.warn('æ²¡æœ‰å¯ç”¨çš„ Worker æ¥å¤„ç†ä»»åŠ¡');
            reject(new Error('æ²¡æœ‰å¯ç”¨çš„ Worker'));
          }
        });
      }
      
      // å–æ¶ˆæ‰€æœ‰ä»»åŠ¡
      async cancelAll() {
        console.log('å–æ¶ˆæ‰€æœ‰ Worker ä»»åŠ¡ - ç›´æ¥ç»ˆæ­¢å¹¶é‡å»º');
        
        try {
          // è®¾ç½®å–æ¶ˆæ ‡è®°
          this.isCancelled = true;
          
          // å¦‚æœæœ‰å¾…è§£å†³çš„ Promiseï¼Œä¼˜é›…åœ°è§£å†³å®ƒè€Œä¸æ˜¯æ‹’ç»
          if (this.taskResolve) {
            console.log('ä¼˜é›…åœ°ç»“æŸå½“å‰è®¡ç®—ä»»åŠ¡');
            this.taskResolve([]); // è¿”å›ç©ºç»“æœè€Œä¸æ˜¯æŠ›å‡ºå¼‚å¸¸
            this.taskResolve = null;
            this.taskReject = null;
          }
          
          // ç›´æ¥ç»ˆæ­¢æ‰€æœ‰ Worker
          this.workers.forEach((worker, index) => {
            try {
              console.log(`ç»ˆæ­¢ Worker ${index}`);
              worker.terminate();
            } catch (error) {
              console.warn(`ç»ˆæ­¢ Worker ${index} æ—¶å‡ºç°è­¦å‘Š:`, error.message);
            }
          });
          
          // æ¸…ç†æ‰€æœ‰çŠ¶æ€
          this.workers = [];
          this.workerStates.clear();
          this.pendingTasks.clear();
          this.currentTaskIndex = 0;
          this.totalTasks = 0;
          this.completedTasks = 0;
          this.allResults = [];
          this.taskQueue = [];
          this.taskId = 0;
          this.globalProgressCallback = null;
          this.dynamicPruningCallback = null;
          this.isInitialized = false;
          
          // é‡æ–°åˆå§‹åŒ– Worker æ± 
          console.log('é‡æ–°åˆå§‹åŒ– Worker æ± ');
          await this.init();
          
          console.log('Worker æ± å·²é‡å»ºå®Œæˆ');
          return { success: true, message: 'è®¡ç®—å·²å–æ¶ˆï¼ŒWorker æ± å·²é‡å»º' };
          
        } catch (error) {
          console.error('å–æ¶ˆä»»åŠ¡è¿‡ç¨‹ä¸­å‡ºç°é”™è¯¯:', error);
          // å³ä½¿å‡ºé”™ä¹Ÿè¦ç¡®ä¿çŠ¶æ€è¢«æ¸…ç†
          this.workers = [];
          this.workerStates.clear();
          this.pendingTasks.clear();
          this.isInitialized = false;
          this.isCancelled = false;
          
          return { success: false, message: 'å–æ¶ˆä»»åŠ¡æ—¶å‡ºç°é”™è¯¯ï¼Œä½†çŠ¶æ€å·²æ¸…ç†', error: error.message };
        }
      }
      
      // é”€æ¯ Worker æ± 
      destroy() {
        console.log('é”€æ¯ Worker æ± ');
        
        // å¦‚æœæœ‰å¾…è§£å†³çš„ Promiseï¼Œæ‹’ç»å®ƒ
        if (this.taskReject) {
          this.taskReject(new Error('Worker æ± å·²é”€æ¯'));
          this.taskResolve = null;
          this.taskReject = null;
        }
        
        // ç»ˆæ­¢æ‰€æœ‰ Worker
        this.workers.forEach((worker, index) => {
          console.log(`é”€æ¯ Worker ${index}`);
          worker.terminate();
        });
        
        // æ¸…ç†æ‰€æœ‰çŠ¶æ€
        this.workers = [];
        this.workerStates.clear();
        this.pendingTasks.clear();
        this.taskQueue = [];
        this.currentTaskIndex = 0;
        this.totalTasks = 0;
        this.completedTasks = 0;
        this.allResults = [];
        this.taskId = 0;
        this.globalProgressCallback = null;
        this.dynamicPruningCallback = null;
        this.isInitialized = false;
        this.isCancelled = false;
        
        console.log('Worker æ± å·²å®Œå…¨é”€æ¯');
      }
    }

    // å¯¼å‡º WorkerPool ç±»
    window.WorkerPool = WorkerPool;
  </script>
  
  <script type="module">
    const MAX = 9;
    let SIZE = 9;

    // Shapes copied from current game.py item_sharp
    const ITEM_SHAPES = [
      [[1, 0], [1, 0], [1, 0], [1, 1]],
      [[0, 1], [0, 1], [1, 1], [0, 1]],
      [[0, 0, 0, 1], [1, 1, 1, 1]],
      [[1, 1, 1, 1], [0, 1, 0, 0]],
      [[1, 1, 1], [1, 0, 0]],
      [[0, 1, 1], [1, 1, 0]],
      [[1, 1], [1, 1]],
      [[1, 1], [1, 0]],
      [[1], [1], [1]],
      [[1, 1, 1]],
      [[1], [1]],
      [[1]]
    ];

    let counts = ITEM_SHAPES.map(_ => 0);
    let pkg = Array.from({ length: SIZE }, (_, i) => Array.from({ length: SIZE }, (_, j) => i >= 2 && i <= 6 && j >= 3 && j <= 5 ? 'o' : 'x'));

    // Persist/restore state -------------------------------------------------
    const LS_COUNTS = 'packing_counts_v1';
    const LS_PKG = 'packing_pkg_v1';
    const LS_RESULTS = 'packing_results_v1';
    
    function saveState() {
      try {
        localStorage.setItem(LS_COUNTS, JSON.stringify(counts));
        localStorage.setItem(LS_PKG, JSON.stringify(pkg));
      } catch (e) { /* ignore quota errors */ }
    }
    
    function saveResults(solutions, selectedIndex = 0) {
      try {
        const resultsData = {
          solutions: solutions,
          selectedIndex: selectedIndex,
          timestamp: Date.now()
        };
        localStorage.setItem(LS_RESULTS, JSON.stringify(resultsData));
      } catch (e) { /* ignore quota errors */ }
    }
    
    function loadState() {
      try {
        const c = JSON.parse(localStorage.getItem(LS_COUNTS) || 'null');
        const p = JSON.parse(localStorage.getItem(LS_PKG) || 'null');
        if (Array.isArray(c) && c.length === ITEM_SHAPES.length && c.every(n => Number.isInteger(n) && n >= 0)) {
          counts = c.slice();
        }
        if (Array.isArray(p) && p.length === SIZE && p.every(r => Array.isArray(r) && r.length === SIZE)) {
          pkg = p.map(r => r.map(v => (v === 'x' ? 'x' : 'o')));
        }
      } catch (e) { /* ignore parse errors */ }
    }
    
    function loadResults() {
      try {
        const resultsData = JSON.parse(localStorage.getItem(LS_RESULTS) || 'null');
        if (resultsData && Array.isArray(resultsData.solutions) && resultsData.solutions.length > 0) {
          return resultsData;
        }
      } catch (e) { /* ignore parse errors */ }
      return null;
    }

    const gridEl = document.getElementById('grid');
    const visEl = document.getElementById('vis');
    const utilEl = document.getElementById('util');
    const shapesEl = document.getElementById('shapes');
    const clearBtn = document.getElementById('clear');
    const fillBtn = document.getElementById('fill');
    const clearCountsBtn = document.getElementById('clearCounts');
    const calculateBtn = document.getElementById('calculate');
    const selectionOverlay = document.getElementById('selectionOverlay');

    clearBtn.onclick = () => {
      pkg = Array.from({ length: SIZE }, (_, i) => Array.from({ length: SIZE }, (_, j) => i >= 2 && i <= 6 && j >= 3 && j <= 5 ? 'o' : 'x'));
      renderGrid();
      saveState();
    };
    fillBtn.onclick = () => {
      pkg = Array.from({ length: SIZE }, () => Array.from({ length: SIZE }, () => 'o'));
      renderGrid();
      saveState();
    };
    clearCountsBtn.onclick = () => {
      counts = counts.map(() => 0);
      document.querySelectorAll('#shapes input[type="number"]').forEach(inp => inp.value = '0');
      saveState();
    };
    calculateBtn.onclick = () => {
      requestSolve();
    };

    // æ‹–åŠ¨é€‰æ‹©ç›¸å…³å˜é‡
    let isDragging = false;
    let isMouseDown = false;
    let dragStartCell = null;
    let dragCurrentCell = null;
    let hasMoved = false; // æ ‡è®°æ˜¯å¦çœŸæ­£å‘ç”Ÿäº†æ‹–åŠ¨

    // è·å–è§¦æ‘¸æˆ–é¼ æ ‡äº‹ä»¶çš„åæ ‡
    function getEventCoordinates(e) {
      if (e.touches && e.touches.length > 0) {
        return { x: e.touches[0].clientX, y: e.touches[0].clientY };
      }
      return { x: e.clientX, y: e.clientY };
    }

    // æ ¹æ®åæ ‡è·å–å¯¹åº”çš„ç½‘æ ¼å•å…ƒæ ¼
    function getCellFromCoordinates(x, y) {
      const element = document.elementFromPoint(x, y);
      if (element && element.classList.contains('cell') && element.dataset.row !== undefined) {
        return {
          row: parseInt(element.dataset.row),
          col: parseInt(element.dataset.col),
          element: element
        };
      }
      return null;
    }

    function renderGrid() {
      gridEl.innerHTML = '';
      gridEl.style.gridTemplateColumns = `repeat(${SIZE}, 30px)`;
      
      for (let r = 0; r < SIZE; r++) {
        for (let c = 0; c < SIZE; c++) {
          const div = document.createElement('div');
          const v = pkg[r][c];
          div.className = 'cell ' + (v === 'x' ? 'block' : 'free');
          div.textContent = v === 'x' ? 'x' : '';
          div.dataset.row = r;
          div.dataset.col = c;
          
          // å•å‡»åˆ‡æ¢åŠŸèƒ½
          div.onclick = (e) => {
            // åªæœ‰åœ¨æ²¡æœ‰å‘ç”Ÿæ‹–åŠ¨çš„æƒ…å†µä¸‹æ‰æ‰§è¡Œå•å‡»åˆ‡æ¢
            if (!hasMoved) {
              pkg[r][c] = pkg[r][c] === 'x' ? 'o' : 'x';
              renderGrid();
              saveState();
            }
          };
          
          // é¼ æ ‡æŒ‰ä¸‹äº‹ä»¶
          div.onmousedown = (e) => {
            e.preventDefault();
            startDrag(r, c);
          };
          
          // è§¦æ‘¸å¼€å§‹äº‹ä»¶
          div.ontouchstart = (e) => {
            e.preventDefault();
            startDrag(r, c);
          };
          
          // è§¦æ‘¸ç»“æŸäº‹ä»¶ - å¤„ç†å•å‡»åˆ‡æ¢
          div.ontouchend = (e) => {
            e.preventDefault();
            // å¦‚æœæ²¡æœ‰å‘ç”Ÿæ‹–åŠ¨ï¼Œæ‰§è¡Œå•å‡»åˆ‡æ¢
            if (!hasMoved && !isDragging) {
              pkg[r][c] = pkg[r][c] === 'x' ? 'o' : 'x';
              renderGrid();
              saveState();
            }
          };
          
          // é¼ æ ‡è¿›å…¥äº‹ä»¶ï¼ˆç”¨äºæ‹–åŠ¨è¿‡ç¨‹ä¸­ï¼‰
          div.onmouseenter = () => {
            if (isMouseDown) {
              updateDragToCell(r, c);
            }
          };
          
          gridEl.appendChild(div);
        }
      }
      
      // å…¨å±€é¼ æ ‡é‡Šæ”¾äº‹ä»¶
      document.onmouseup = () => {
        endDrag();
      };
      
      // å…¨å±€è§¦æ‘¸ç»“æŸäº‹ä»¶
      document.ontouchend = () => {
        endDrag();
      };
      
      // å…¨å±€è§¦æ‘¸ç§»åŠ¨äº‹ä»¶ï¼ˆç”¨äºæ‹–åŠ¨è¿‡ç¨‹ä¸­ï¼‰
      document.ontouchmove = (e) => {
        if (isMouseDown) {
          e.preventDefault();
          const coords = getEventCoordinates(e);
          const cellInfo = getCellFromCoordinates(coords.x, coords.y);
          if (cellInfo) {
            updateDragToCell(cellInfo.row, cellInfo.col);
          }
        }
      };
    }

    // å¼€å§‹æ‹–åŠ¨
    function startDrag(row, col) {
      isMouseDown = true;
      hasMoved = false;
      dragStartCell = { row, col };
      dragCurrentCell = { row, col };
    }

    // æ›´æ–°æ‹–åŠ¨åˆ°æŒ‡å®šå•å…ƒæ ¼
    function updateDragToCell(row, col) {
      // æ£€æŸ¥æ˜¯å¦çœŸæ­£ç§»åŠ¨åˆ°äº†ä¸åŒçš„æ ¼å­
      if (!dragCurrentCell || dragCurrentCell.row !== row || dragCurrentCell.col !== col) {
        if (!isDragging) {
          // ç¬¬ä¸€æ¬¡ç§»åŠ¨ï¼Œå¼€å§‹æ‹–åŠ¨æ¨¡å¼
          isDragging = true;
          hasMoved = true;
          updateSelectionOverlay();
        }
        dragCurrentCell = { row, col };
        updateSelectionOverlay();
      }
    }

    // ç»“æŸæ‹–åŠ¨
    function endDrag() {
      if (isDragging && hasMoved) {
        applySelection();
      }
      
      // é‡ç½®æ‰€æœ‰çŠ¶æ€
      isDragging = false;
      isMouseDown = false;
      dragStartCell = null;
      dragCurrentCell = null;
      selectionOverlay.style.display = 'none';
      
      // å»¶è¿Ÿé‡ç½®hasMovedï¼Œè®©clickäº‹ä»¶èƒ½å¤Ÿæ­£ç¡®åˆ¤æ–­
      setTimeout(() => {
        hasMoved = false;
      }, 10);
    }

    // æ›´æ–°é€‰æ‹©é®ç½©å±‚
    function updateSelectionOverlay() {
      if (!isDragging || !dragStartCell || !dragCurrentCell) return;
      
      const cellSize = 30; // åŒ…æ‹¬è¾¹æ¡†çš„æ ¼å­å¤§å°
      const gap = 6; // ç½‘æ ¼é—´è·
      
      const startRow = Math.min(dragStartCell.row, dragCurrentCell.row);
      const endRow = Math.max(dragStartCell.row, dragCurrentCell.row);
      const startCol = Math.min(dragStartCell.col, dragCurrentCell.col);
      const endCol = Math.max(dragStartCell.col, dragCurrentCell.col);
      
      const left = startCol * cellSize + startCol * gap;
      const top = startRow * cellSize + startRow * gap;
      const width = (endCol - startCol + 1) * cellSize + (endCol - startCol) * gap;
      const height = (endRow - startRow + 1) * cellSize + (endRow - startRow) * gap;
      
      selectionOverlay.style.left = left + 'px';
      selectionOverlay.style.top = top + 'px';
      selectionOverlay.style.width = width + 'px';
      selectionOverlay.style.height = height + 'px';
      selectionOverlay.style.display = 'block';
    }

    // åº”ç”¨é€‰æ‹©åŒºåŸŸ
    function applySelection() {
      if (!dragStartCell || !dragCurrentCell) return;
      
      const startRow = Math.min(dragStartCell.row, dragCurrentCell.row);
      const endRow = Math.max(dragStartCell.row, dragCurrentCell.row);
      const startCol = Math.min(dragStartCell.col, dragCurrentCell.col);
      const endCol = Math.max(dragStartCell.col, dragCurrentCell.col);
      
      // å°†é€‰æ‹©åŒºåŸŸå†…çš„æ‰€æœ‰æ ¼å­è®¾ç½®ä¸ºå¯ç”¨
      for (let r = startRow; r <= endRow; r++) {
        for (let c = startCol; c <= endCol; c++) {
          pkg[r][c] = 'o';
        }
      }
      
      renderGrid();
      saveState();
    }

    function renderShapes() {
      shapesEl.innerHTML = '';
      ITEM_SHAPES.forEach((s, idx) => {
        const row = document.createElement('div');
        row.className = 'row';

        const label = document.createElement('div');
        label.textContent = `${String.fromCharCode(65 + (idx % 26))}`;
        label.style.fontWeight = '600';
        label.style.fontSize = '14px';
        label.style.color = '#374151';
        label.style.minWidth = '18px';
        label.style.flexShrink = '0';

        label.style.textAlign = 'center';

        const preview = document.createElement('div');

        preview.className = 'shape';
        preview.style.gridTemplateColumns = `repeat(${s[0].length}, 10px)`;
        s.forEach(rr => rr.forEach(cc => {
          const sq = document.createElement('div');
          sq.className = 'sq ' + (cc ? 'on' : '');
          preview.appendChild(sq);
        }));

        const input = document.createElement('input');
        input.type = 'number';
        input.min = '0';
        input.value = counts[idx];
        input.style.width = '60px';
        input.style.minWidth = '50px';
        input.style.maxWidth = '70px';
        input.style.textAlign = 'center';
        input.style.fontWeight = '500';
        input.style.flexShrink = '0'; /* é˜²æ­¢è¾“å…¥æ¡†è¢«è¿‡åº¦å‹ç¼© */

        input.oninput = () => {
          counts[idx] = Math.max(0, parseInt(input.value || '0', 10));
          saveState();
        };


        row.appendChild(label);
        row.appendChild(preview);
        row.appendChild(input);
        shapesEl.appendChild(row);
      });
    }

    function area(shape) { return shape.flat().reduce((a, b) => a + (b ? 1 : 0), 0); }

    // Solver (ported to JS) ---------------------------------------------
    function computeFreeCells(grid) {
      let n = 0; for (const row of grid) for (const c of row) if (c === 'o') n++; return n;
    }
    function countFilled(grid) {
      let n = 0; for (const row of grid) for (const c of row) if (Array.isArray(c)) n++; return n;
    }
    function deriveCountsFromGrid(grid, shapesLen) {
      // Marks are ['i', idx, k]; count how many marks per idx
      const counts = Array(shapesLen).fill(0);
      for (const row of grid) {
        for (const c of row) {
          if (Array.isArray(c) && c[0] === 'i') counts[c[1]] += 1;
        }
      }
      // Each item contributes area equal to item shape area; to get piece counts, divide by area
      return counts.map((cells, idx) => {
        const areaVal = area(ITEM_SHAPES[idx]);
        return areaVal > 0 ? Math.round(cells / areaVal) : 0;
      });
    }

    // åˆ›å»ºå†…è”çš„ Worker è„šæœ¬
    const workerScript = `
// Worker è„šæœ¬ï¼šåœ¨ç‹¬ç«‹çº¿ç¨‹ä¸­è°ƒç”¨ WASM æ±‚è§£å™¨
let wasmSolver = null;
let isInitialized = false;

// åˆå§‹åŒ– WASM æ¨¡å—
async function initWasm() {
  if (wasmSolver) return wasmSolver;
  
  try {
    // åŠ¨æ€å¯¼å…¥ WASM æ¨¡å— - ä½¿ç”¨ç»å¯¹è·¯å¾„
    const wasmModule = await import(self.location.origin + '/pkg/packing_solver.js');
    await wasmModule.default();
    wasmSolver = new wasmModule.WasmPackingSolver();
    isInitialized = true;
    // console.log('Worker WASM æ±‚è§£å™¨åˆå§‹åŒ–æˆåŠŸ');
    return wasmSolver;
  } catch (error) {
    console.error('Worker WASM åˆå§‹åŒ–å¤±è´¥:', error);
    throw error;
  }
}

// å¤„ç†ä¸»çº¿ç¨‹å‘é€çš„æ¶ˆæ¯
self.onmessage = async function(e) {
  const { type, data, taskId } = e.data;
  
  try {
    switch (type) {
      case 'init':
        // åˆå§‹åŒ– WASM æ¨¡å—
        await initWasm();
        self.postMessage({
          type: 'init_complete',
          taskId,
          success: true
        });
        break;
        
      case 'solve_single': {
        // å¤„ç†å•ä¸ªç»„åˆä»»åŠ¡
        if (!isInitialized) {
          await initWasm();
        }
        
        const { combination, grid: singleGrid, shapes: singleShapes, originalIndex } = data;
        
        try {
          // é‡ç½®å–æ¶ˆæ ‡å¿—
          wasmSolver.set_cancel(false);
          
          // ç›´æ¥è°ƒç”¨ WASM æ±‚è§£å™¨ï¼Œä¼ é€’ç‹¬ç«‹å‚æ•°
          const result = wasmSolver.solve_combination(
            singleGrid,
            singleShapes, 
            combination,
            originalIndex
          );
          
          const taskResult = {
            bestFilled: result.best_filled,
            solutions: result.solutions,
            combinationIndex: result.combination_index,
            counts: result.counts,
            cancelled: result.cancelled
          };
          
          // å‘é€å•ä¸ªä»»åŠ¡å®Œæˆç»“æœ
          self.postMessage({
            type: 'single_task_complete',
            taskId,
            results: [taskResult]
          });
          
        } catch (error) {
          console.error(\`Worker æ±‚è§£ç»„åˆ \${originalIndex} æ—¶å‡ºé”™:\`, error);
          
          const errorResult = {
            bestFilled: -1,
            solutions: [],
            combinationIndex: originalIndex,
            counts: combination,
            cancelled: false,
            error: error.message
          };
          
          self.postMessage({
            type: 'single_task_complete',
            taskId,
            results: [errorResult]
          });
        }
        break;
      }
      case 'cancel':
        // å–æ¶ˆå½“å‰è®¡ç®—
        if (wasmSolver) {
          wasmSolver.set_cancel(true);
        }
        self.postMessage({
          type: 'cancel_complete',
          taskId
        });
        break;
        
      default:
        console.warn('Worker æ”¶åˆ°æœªçŸ¥æ¶ˆæ¯ç±»å‹:', type);
    }
  } catch (error) {
    console.error('Worker å¤„ç†æ¶ˆæ¯æ—¶å‡ºé”™:', error);
    self.postMessage({
      type: 'error',
      taskId,
      error: error.message
    });
  }
};
    `;

    // åˆ›å»º Blob URL ç”¨äº Worker
    const workerBlob = new Blob([workerScript], { type: 'application/javascript' });
    const workerUrl = URL.createObjectURL(workerBlob);

    // å¤š Worker WASM æ¶æ„
    let workerPool = null;
    let currentSolveId = 0;
    const MAX_WORKERS = navigator.hardwareConcurrency || 1; // ä½¿ç”¨CPUæ ¸æ•°ï¼Œé»˜è®¤1ä¸ª
    let isCalculating = false; // æ ‡è®°æ˜¯å¦æ­£åœ¨è®¡ç®—
    let currentCalculationPromise = null; // å½“å‰è®¡ç®—çš„Promiseï¼Œç”¨äºå–æ¶ˆ
    let workerPoolInitPromise = null; // Worker æ± åˆå§‹åŒ–çš„ Promise
    
    // åˆå§‹åŒ– Worker æ± 
    async function initWorkerPool() {
      if (workerPool) return workerPool;
      
      // å¦‚æœå·²ç»åœ¨åˆå§‹åŒ–ä¸­ï¼Œè¿”å›åŒä¸€ä¸ª Promise
      if (workerPoolInitPromise) {
        return workerPoolInitPromise;
      }
      
      workerPoolInitPromise = (async () => {
        try {
          workerPool = new WorkerPool(workerUrl, MAX_WORKERS);
          await workerPool.init();
          console.log(`Worker æ± åˆå§‹åŒ–æˆåŠŸï¼Œä½¿ç”¨ ${MAX_WORKERS} ä¸ª Worker`);
          return workerPool;
        } catch (error) {
          console.error('Worker æ± åˆå§‹åŒ–å¤±è´¥:', error);
          workerPoolInitPromise = null; // é‡ç½®ï¼Œå…è®¸é‡è¯•
          throw error;
        }
      })();
      
      return workerPoolInitPromise;
    }
    
    // ç¬¬ä¸€é˜¶æ®µï¼šç”Ÿæˆæ‰€æœ‰é¥±å’Œçš„ç‰©å“ç»„åˆï¼ˆæ— æ³•å†æ·»åŠ ä»»ä½•ç‰©å“çš„ç»„åˆï¼‰
    function generateValidCombinations(shapes, maxCounts, freeArea) {
      const validCombinations = [];
      
      // é¢„è®¡ç®—æ¯ä¸ªç‰©å“çš„é¢ç§¯
      const shapeAreas = shapes.map(shape => area(shape));
      
      function isSaturated(combination, currentArea) {
        // æ£€æŸ¥æ˜¯å¦è¿˜èƒ½æ·»åŠ ä»»ä½•ç‰©å“
        for (let i = 0; i < shapes.length; i++) {
          if (combination[i] < maxCounts[i] && currentArea + shapeAreas[i] <= freeArea) {
            return false; // è¿˜èƒ½æ·»åŠ ç¬¬iç§ç‰©å“
          }
        }
        return true; // æ— æ³•å†æ·»åŠ ä»»ä½•ç‰©å“ï¼Œç»„åˆå·²é¥±å’Œ
      }
      
      function backtrack(index, currentCombination, currentArea) {
        if (currentArea > freeArea) return; // å‰ªæï¼šé¢ç§¯è¶…é™
        
        if (index === shapes.length) {
          if (currentArea > 0 && isSaturated(currentCombination, currentArea)) {
            // åªä¿ç•™é¥±å’Œçš„ç»„åˆï¼ˆæ— æ³•å†æ·»åŠ ä»»ä½•ç‰©å“ï¼‰
            validCombinations.push([...currentCombination]);
          }
          return;
        }
        
        const shapeArea = shapeAreas[index];
        const maxPossible = Math.floor((freeArea - currentArea) / shapeArea);
        const actualMax = Math.min(maxCounts[index], maxPossible);
        
        for (let count = 0; count <= actualMax; count++) {
          currentCombination[index] = count;
          backtrack(index + 1, currentCombination, currentArea + count * shapeArea);
        }
      }
      
      backtrack(0, new Array(shapes.length).fill(0), 0);
      return validCombinations;
    }
    
    // Worker æ± ç®¡ç†
    async function ensureWorkerPoolReady() {
      if (!workerPool) {
        await initWorkerPool();
      }
      console.log('Worker æ± å·²å‡†å¤‡å°±ç»ª');
    }
    
    // å–æ¶ˆ Worker è®¡ç®—
    async function cancelWorkerCalculation() {
      if (workerPool) {
        try {
          const result = await workerPool.cancelAll();
          if (result.success) {
            console.log('Worker è®¡ç®—å·²å–æ¶ˆ:', result.message);
          } else {
            console.warn('å–æ¶ˆ Worker è®¡ç®—æ—¶å‡ºç°é—®é¢˜:', result.message);
            if (result.error) {
              console.warn('é”™è¯¯è¯¦æƒ…:', result.error);
            }
          }
        } catch (error) {
          console.error('å–æ¶ˆ Worker è®¡ç®—æ—¶å‘ç”Ÿå¼‚å¸¸:', error);
          // å³ä½¿å‡ºç°å¼‚å¸¸ï¼Œä¹Ÿä¸å‘ä¸ŠæŠ›å‡ºï¼Œä¿æŒä¼˜é›…å¤„ç†
        }
      }
    }
    
    // è¾…åŠ©å‡½æ•°ï¼šæ£€æŸ¥ç»„åˆAæ˜¯å¦æ˜¯ç»„åˆBçš„å­é›†
    function isSubset(smaller, larger) {
      return smaller.every((count, idx) => count <= larger[idx]);
    }
    
    // è¾…åŠ©å‡½æ•°ï¼šè®¡ç®—ç»„åˆçš„æ€»é¢ç§¯
    function getCombinationArea(combination, shapes) {
      return combination.reduce((total, count, idx) => {
        return total + count * area(shapes[idx]);
      }, 0);
    }
    
    // æ–°çš„å¤š Worker å¹¶è¡Œæ±‚è§£æ¶æ„
    async function solveWithNewArchitecture(grid, shapes, counts, progressCallback, cancelToken) {
      // è®°å½•æ±‚è§£å¼€å§‹æ—¶é—´
      const solveStartTime = performance.now();
      
      const freeArea = computeFreeCells(grid);
      
      // æ£€æŸ¥æ˜¯å¦å·²å–æ¶ˆ
      if (cancelToken && cancelToken.cancelled) {
        return { bestFilled: 0, solutions: [] };
      }
      
      // ç¡®ä¿ Worker æ± å·²å‡†å¤‡å°±ç»ª
      await ensureWorkerPoolReady();
      
      // ç¬¬ä¸€é˜¶æ®µï¼šç”Ÿæˆæ‰€æœ‰æœ‰æ•ˆç»„åˆ
      console.log('ç¬¬ä¸€é˜¶æ®µï¼šç”Ÿæˆæœ‰æ•ˆç‰©å“ç»„åˆ...');
      const validCombinations = generateValidCombinations(shapes, counts, freeArea);
      console.log(`æ‰¾åˆ° ${validCombinations.length} ä¸ªæœ‰æ•ˆç»„åˆ`);
      
      if (validCombinations.length === 0) {
        return { bestFilled: 0, solutions: [] };
      }
      
      // å†æ¬¡æ£€æŸ¥æ˜¯å¦å·²å–æ¶ˆ
      if (cancelToken && cancelToken.cancelled) {
        return { bestFilled: 0, solutions: [] };
      }
      
      // æŒ‰é¢ç§¯ä»å¤§åˆ°å°æ’åºç»„åˆï¼Œä¼˜å…ˆè®¡ç®—å¤§é¢ç§¯ç»„åˆ
      validCombinations.sort((a, b) => {
        const areaA = getCombinationArea(a, shapes);
        const areaB = getCombinationArea(b, shapes);
        return areaB - areaA;
      });
      
      console.log(`ä½¿ç”¨å¤š Worker å¹¶è¡Œè®¡ç®—ï¼ˆWorker æ•°é‡ï¼š${MAX_WORKERS}ï¼‰`);
      
      // ç¬¬äºŒé˜¶æ®µï¼šä½¿ç”¨å¤š Worker å¹¶è¡Œè®¡ç®—æ¯ä¸ªç»„åˆçš„æœ€ä¼˜æ”¾ç½®
      console.log('ç¬¬äºŒé˜¶æ®µï¼šå¤š Worker åŠ¨æ€å‰ªæå¹¶è¡Œè®¡ç®—æœ€ä¼˜æ”¾ç½®æ–¹æ¡ˆ...');
      const solveId = ++currentSolveId;
      
      // ç”¨äºè·Ÿè¸ªå½“å‰æœ€ä½³ç»„åˆï¼Œå®ç°åŠ¨æ€å‰ªæ
      let currentBestCombination = null;
      let currentBestFilled = -1;
      let totalSkippedCount = 0;
      
      // åˆ›å»ºå¾…å¤„ç†ä»»åŠ¡é˜Ÿåˆ—ï¼ˆä¸è¿›è¡Œé¢„å‰ªæï¼‰
      const allCombinations = validCombinations.map((combination, index) => ({
        combination,
        originalIndex: index
      }));
      
      console.log(`åŠ¨æ€ä»»åŠ¡åˆ†é…ï¼šæ€»ç»„åˆ ${validCombinations.length}ï¼Œå¯ç”¨å®æ—¶åŠ¨æ€å‰ªæ`);
      
      // åŠ¨æ€è¿›åº¦å›è°ƒ
      const dynamicProgressCallback = (progress) => {
        if (progressCallback) {
          progressCallback(progress);
        }
      };
      
      // åŠ¨æ€å‰ªæå›è°ƒå‡½æ•°
      const dynamicPruningCallback = (newResults) => {
        let prunedCount = 0;
        
        // æ›´æ–°å…¨å±€æœ€ä¼˜è§£
        for (const result of newResults) {
          if (result.bestFilled > currentBestFilled) {
            const oldBestFilled = currentBestFilled;
            currentBestFilled = result.bestFilled;
            currentBestCombination = result.counts;
            console.log(`ğŸ¯ å®æ—¶æ›´æ–°å…¨å±€æœ€ä¼˜è§£ï¼šå¡«å……æ•° ${oldBestFilled} â†’ ${currentBestFilled}`);
          }
        }
        
        // å¯¹å‰©ä½™ä»»åŠ¡é˜Ÿåˆ—è¿›è¡Œå‰ªæ
        if (currentBestFilled > 0 && currentBestCombination) {
          const originalQueueLength = workerPool.taskQueue.length;
          const remainingTasks = [];
          
          for (let i = workerPool.currentTaskIndex; i < workerPool.taskQueue.length; i++) {
            const task = workerPool.taskQueue[i];
            const combination = task.combination;
            let shouldSkip = false;
            
            // å‰ªæç­–ç•¥1ï¼šå­é›†å‰ªæ
            if (isSubset(combination, currentBestCombination) && 
                !combination.every((c, idx) => c === currentBestCombination[idx])) {
              shouldSkip = true;
            }
            
            // å‰ªæç­–ç•¥2ï¼šé¢ç§¯å‰ªæ
            if (!shouldSkip) {
              const theoreticalMaxArea = getCombinationArea(combination, shapes);
              if (theoreticalMaxArea < currentBestFilled) {
                shouldSkip = true;
              }
            }
            
            if (!shouldSkip) {
              remainingTasks.push(task);
            } else {
              prunedCount++;
            }
          }
          
          // æ›´æ–°ä»»åŠ¡é˜Ÿåˆ—
          const newQueue = workerPool.taskQueue.slice(0, workerPool.currentTaskIndex).concat(remainingTasks);
          workerPool.taskQueue = newQueue;
          
          totalSkippedCount += prunedCount;
          
          if (prunedCount > 0) {
            console.log(`ğŸ”¥ å®æ—¶å‰ªæï¼šç§»é™¤ ${prunedCount} ä¸ªä»»åŠ¡ï¼Œå‰©ä½™ ${remainingTasks.length} ä¸ªä»»åŠ¡`);
          }
        }
        
        return prunedCount;
      };
      
      // ä½¿ç”¨åŠ¨æ€ä»»åŠ¡åˆ†é…å¤„ç†æ‰€æœ‰ç»„åˆï¼Œå¯ç”¨åŠ¨æ€å‰ªæ
      const allResults = await workerPool.solveDynamic(
        allCombinations,
        grid,
        shapes,
        dynamicProgressCallback,
        dynamicPruningCallback
      );
      
      // æ£€æŸ¥æ˜¯å¦å·²å–æ¶ˆ
      if (cancelToken && cancelToken.cancelled) {
        return { bestFilled: 0, solutions: [] };
      }
      
      // æœ€ç»ˆæ›´æ–°å…¨å±€æœ€ä¼˜è§£ï¼ˆç¡®ä¿æ²¡æœ‰é—æ¼ï¼‰
      for (const result of allResults) {
        if (result.bestFilled > currentBestFilled) {
          const oldBestFilled = currentBestFilled;
          currentBestFilled = result.bestFilled;
          currentBestCombination = result.counts;
          console.log(`ğŸ¯ æœ€ç»ˆæ›´æ–°å…¨å±€æœ€ä¼˜è§£ï¼šå¡«å……æ•° ${oldBestFilled} â†’ ${currentBestFilled}`);
        }
      }
      
      const actualCalculated = allResults.length;
      const pruningEfficiency = validCombinations.length > 0 ? (totalSkippedCount / validCombinations.length * 100).toFixed(1) : '0.0';
      console.log(`ğŸ“Š åŠ¨æ€å‰ªæç»Ÿè®¡ï¼šæ€»ç»„åˆ ${validCombinations.length}ï¼ŒåŠ¨æ€è·³è¿‡ ${totalSkippedCount} (${pruningEfficiency}%)ï¼Œå®é™…è®¡ç®— ${actualCalculated}`);
      
      // ç¬¬ä¸‰é˜¶æ®µï¼šæ±‡æ€»æœ€ä¼˜ç»“æœ
      console.log('ç¬¬ä¸‰é˜¶æ®µï¼šæ±‡æ€»æœ€ä¼˜ç»“æœ...');
      const successfulResults = allResults
        .filter(r => r.solutions && r.solutions.length > 0 && !r.cancelled && !r.error);
      
      const cancelledResults = allResults
        .filter(r => r.cancelled)
        .length;
      
      const errorResults = allResults
        .filter(r => r.error)
        .length;
      
      console.log(`ğŸ“Š ä»»åŠ¡ç»Ÿè®¡ï¼šæˆåŠŸ ${successfulResults.length}ï¼Œå–æ¶ˆ ${cancelledResults}ï¼Œé”™è¯¯ ${errorResults}ï¼Œæ€»è®¡ ${allResults.length}`);
      
      if (successfulResults.length === 0) {
        return { bestFilled: 0, solutions: [] };
      }
      
      // æ‰¾åˆ°å…¨å±€æœ€ä¼˜å¡«å……æ•°
      const globalBestFilled = Math.max(...successfulResults.map(r => r.bestFilled));
      
      // è§£å‹ç¼©å‡½æ•°ï¼ˆåœ¨ä¸»çº¿ç¨‹ä¸­ï¼‰
      function decompressGridInMain(compressed, originalGrid) {
        const grid = originalGrid.map(r => r.slice());
        for (const p of compressed.placements) {
          grid[p.r][p.c] = ['i', p.idx, p.inst];
        }
        return grid;
      }
      
      // æ”¶é›†æ‰€æœ‰æœ€ä¼˜è§£å¹¶è§£å‹ç¼©
      const allBestSolutions = [];
      const solutionKeys = new Set(); // ç”¨äºä¸»çº¿ç¨‹æœ€ç»ˆå»é‡
      
      for (const result of successfulResults) {
        if (result.bestFilled === globalBestFilled) {
          for (const solution of result.solutions) {
            // è®¡ç®—è§£å†³æ–¹æ¡ˆçš„å”¯ä¸€é”®
            const usedCounts = Array(ITEM_SHAPES.length).fill(0);
            const instanceCounts = new Map();
            
            for (const p of solution.compressed.placements) {
              const key = `${p.idx}_${p.inst}`;
              if (!instanceCounts.has(key)) {
                instanceCounts.set(key, 0);
                usedCounts[p.idx]++;
              }
            }
            
            const solutionKey = usedCounts.join(',');
            if (!solutionKeys.has(solutionKey)) {
              solutionKeys.add(solutionKey);
              
              // åªåœ¨éœ€è¦æ—¶è§£å‹ç¼©ç½‘æ ¼
              const decompressedGrid = decompressGridInMain(solution.compressed, grid);
              
              allBestSolutions.push({
                filled: solution.filled,
                grid: decompressedGrid
              });
              
              // é™åˆ¶æœ€ç»ˆè§£å†³æ–¹æ¡ˆæ•°é‡ï¼Œé˜²æ­¢ä¸»çº¿ç¨‹å†…å­˜æº¢å‡º
              if (allBestSolutions.length >= 50) {
                console.log('è¾¾åˆ°è§£å†³æ–¹æ¡ˆæ•°é‡é™åˆ¶ï¼Œåœæ­¢æ”¶é›†æ›´å¤šæ–¹æ¡ˆ');
                break;
              }
            }
          }
        }
        
        if (allBestSolutions.length >= 50) break;
      }
      
      // è®¡ç®—æ±‚è§£è€—æ—¶
      const solveEndTime = performance.now();
      const solveDuration = (solveEndTime - solveStartTime) / 1000; // è½¬æ¢ä¸ºç§’
      
      console.log(`æœ€ç»ˆæ”¶é›†åˆ° ${allBestSolutions.length} ä¸ªä¸åŒçš„æœ€ä¼˜è§£å†³æ–¹æ¡ˆï¼Œæ±‚è§£è€—æ—¶: ${solveDuration.toFixed(2)}ç§’`);
      
      return { 
        bestFilled: globalBestFilled, 
        solutions: allBestSolutions 
      };
    }



    function formatResultJSGrid(bestGrid, originalGrid) {
      const totalFree = computeFreeCells(originalGrid);
      const filled = countFilled(bestGrid);
      const util = totalFree === 0 ? 0 : filled / totalFree;
      const vis = [];
      const idGrid = [];
      for (let i = 0; i < bestGrid.length; i++) {
        const row = [];
        const idRow = [];
        for (let j = 0; j < bestGrid[0].length; j++) {
          const cell = bestGrid[i][j];
          if (cell === 'x' && originalGrid[i][j] === 'o') row.push('o');
          else if (cell === 'x' || cell === 'o') row.push(cell);
          else if (Array.isArray(cell)) {
            const idx = cell[1];
            row.push(String.fromCharCode(65 + (idx % 26)));
          } else row.push(cell);
          // id grid: store item idx and instance id if present
          if (Array.isArray(cell) && cell[0] === 'i') {
            idRow.push({ idx: cell[1], inst: cell[2] });
          } else {
            idRow.push(null);
          }
        }
        vis.push(row);
        idGrid.push(idRow);
      }
      return { util, vis, idGrid };
    }

    function renderVis(grid, idGrid) {
      const rows = grid.length, cols = grid[0]?.length || 0;
      visEl.style.gridTemplateColumns = `repeat(${cols}, 24px)`;
      visEl.innerHTML = '';
      // Build high-contrast colors for instances and ensure adjacent instances differ strongly
      function keyOf(info) { return info ? `${info.idx}#${info.inst}` : '' }
      function listInstances() {
        const set = new Set();
        for (let r = 0; r < rows; r++) for (let c = 0; c < cols; c++) {
          const info = idGrid ? idGrid[r][c] : null;
          if (info) set.add(keyOf(info));
        }
        return Array.from(set);
      }
      function buildAdj() {
        const adj = new Map();
        const add = (a, b) => { if (!adj.has(a)) adj.set(a, new Set()); if (!adj.has(b)) adj.set(b, new Set()); if (a !== b) { adj.get(a).add(b); adj.get(b).add(a); } };
        for (let r = 0; r < rows; r++) for (let c = 0; c < cols; c++) {
          const a = idGrid ? idGrid[r][c] : null; if (!a) continue;
          const ka = keyOf(a);
          if (r + 1 < rows) { const b = idGrid[r + 1][c]; if (b && keyOf(b) !== ka) add(ka, keyOf(b)); }
          if (c + 1 < cols) { const b = idGrid[r][c + 1]; if (b && keyOf(b) !== ka) add(ka, keyOf(b)); }
        }
        return adj;
      }
      function generatePalette() {
        const hs = []; for (let h = 0; h < 360; h += 30) hs.push(h);
        const palette = [];
        const sats = [75, 85];
        const lights = [45, 55];
        for (const h of hs) {
          for (const s of sats) { for (const l of lights) { palette.push({ h, s, l }); } }
        }
        return palette;
      }
      function hueDist(a, b) {
        const d = Math.abs(a - b) % 360; return Math.min(d, 360 - d);
      }
      function colorDistance(c1, c2) {
        if (!c1 || !c2) return 360;
        return hueDist(c1.h, c2.h) + Math.abs((c1.l || 0) - (c2.l || 0)) * 0.5 + Math.abs((c1.s || 0) - (c2.s || 0)) * 0.2;
      }
      function toCss(c) { return `hsl(${c.h}deg ${c.s}% ${c.l}%)`; }
      function darker(c, dl = 15) { return { h: c.h, s: c.s, l: Math.max(10, c.l - dl) }; }
      function textColor(c) { return (c.l < 50) ? '#ffffff' : '#111827'; }
      function assignColors(adj) {
        const nodes = listInstances();
        const palette = generatePalette();
        // order by degree desc
        const degree = new Map();
        nodes.forEach(k => degree.set(k, (adj.get(k)?.size) || 0));
        nodes.sort((a, b) => ((degree.get(b) || 0) - (degree.get(a) || 0)));
        const colorMap = new Map();
        for (const k of nodes) {
          const neighborColors = Array.from(adj.get(k) || []).map(n => colorMap.get(n)).filter(Boolean);
          let best = null, bestScore = -1;
          for (const c of palette) {
            const minDist = neighborColors.length ? Math.min(...neighborColors.map(nc => colorDistance(c, nc))) : 360;
            if (minDist > bestScore) { bestScore = minDist; best = c; }
          }
          // fallback in unlikely case
          colorMap.set(k, best || palette[0]);
        }
        return colorMap;
      }
      const adj = idGrid ? buildAdj() : new Map();
      const colorMap = idGrid ? assignColors(adj) : new Map();
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          const div = document.createElement('div');
          div.className = 'cell';
          const v = grid[r][c];
          const info = idGrid ? idGrid[r][c] : null;
          if (v === 'x') { div.classList.add('block'); div.textContent = 'x'; }
          else if (v === 'o') { div.classList.add('free'); div.textContent = ''; }
          else {
            div.classList.add('free');
            div.textContent = v;
          }
          // Fill color per item instance (no colored borders needed)
          if (info) {
            const k = keyOf(info);
            const colObj = colorMap.get(k);
            if (colObj) {
              const fill = toCss(colObj);
              div.style.backgroundColor = fill;
              div.style.color = textColor(colObj);
            }
          }
          visEl.appendChild(div);
        }
      }
    }

    function renderCountsSummary(usedCounts) {
      const summaryEl = document.getElementById('countsSummary');
      summaryEl.innerHTML = ''; // æ¸…ç©ºå†…å®¹
      
      const hasUsedItems = usedCounts.some(count => count > 0);
      if (!hasUsedItems) {
        summaryEl.textContent = '';
        return;
      }
      
      // åˆ›å»ºæ ‡é¢˜
      const titleSpan = document.createElement('span');
      titleSpan.textContent = 'ä½¿ç”¨æ•°é‡ï¼š';
      titleSpan.style.marginRight = '8px';
      summaryEl.appendChild(titleSpan);
      
      // ä¸ºæ¯ä¸ªä½¿ç”¨çš„ç‰©å“åˆ›å»ºå½¢çŠ¶æ˜¾ç¤º
      for (let idx = 0; idx < ITEM_SHAPES.length; idx++) {
        const provided = counts[idx] || 0; // ç”¨æˆ·æä¾›çš„æ•°é‡
        if (provided <= 0) continue; // åªæ˜¾ç¤ºç”¨æˆ·è®¾ç½®äº†æ•°é‡çš„ç‰©å“
        
        const used = usedCounts[idx] || 0;
        const remain = Math.max(0, provided - used);
        
        // åˆ›å»ºç‰©å“å®¹å™¨
        const itemContainer = document.createElement('span');
        itemContainer.style.display = 'inline-flex';
        itemContainer.style.alignItems = 'center'; // å‚ç›´å±…ä¸­
        itemContainer.style.marginRight = '12px';
        itemContainer.style.marginBottom = '4px';
        itemContainer.style.verticalAlign = 'middle'; // ç¡®ä¿æ•´ä¸ªå®¹å™¨ç›¸å¯¹äºå…¶ä»–å†…å®¹å‚ç›´å±…ä¸­
        
        // åˆ›å»ºç¼©å°çš„å½¢çŠ¶æ˜¾ç¤º
        const shapeDiv = document.createElement('div');
        shapeDiv.className = 'shape';
        shapeDiv.style.display = 'inline-grid';
        shapeDiv.style.gap = '1px';
        shapeDiv.style.padding = '2px';
        shapeDiv.style.background = '#f9fafb';
        shapeDiv.style.border = '1px solid var(--border)';
        shapeDiv.style.borderRadius = '4px';
        shapeDiv.style.marginRight = '4px';

        
        const shape = ITEM_SHAPES[idx];
        shapeDiv.style.gridTemplateColumns = `repeat(${shape[0].length}, 6px)`;
        
        shape.forEach(row => {
          row.forEach(cell => {
            const sq = document.createElement('div');
            sq.style.width = '6px';
            sq.style.height = '6px';
            sq.style.border = '1px solid #cbd5e1';
            sq.style.borderRadius = '1px';
            sq.style.background = cell ? '#64748b' : '#fff';
            shapeDiv.appendChild(sq);
          });
        });
        
        // åˆ›å»ºæ•°é‡æ–‡æœ¬
        const countText = document.createElement('span');
        countText.style.fontSize = '12px';
        countText.style.color = 'var(--muted)';
        countText.style.lineHeight = '1'; // è®¾ç½®è¡Œé«˜ä¸º1ï¼Œé¿å…é¢å¤–çš„è¡Œé—´è·å½±å“å¯¹é½
        countText.textContent = remain > 0 ? `${used}(${remain})` : `${used}`;
        
        itemContainer.appendChild(shapeDiv);
        itemContainer.appendChild(countText);
        summaryEl.appendChild(itemContainer);
      }
    }

    const solutionSelect = document.getElementById('solutionSelect');
    const solutionCountEl = document.getElementById('solutionCount');
    let solveTimer = null;
    let currentSolutions = [];
    let progressTimeout = null; // è¿›åº¦æ¡æ˜¾ç¤ºçš„å®šæ—¶å™¨
    
    function loadAndDisplayResults() {
      const resultsData = loadResults();
      if (!resultsData || !resultsData.solutions || resultsData.solutions.length === 0) {
        // æ²¡æœ‰ä¿å­˜çš„ç»“æœï¼Œæ˜¾ç¤ºé»˜è®¤çŠ¶æ€
        utilEl.innerHTML = 'åˆ©ç”¨ç‡: --';
        visEl.innerHTML = '';
        document.getElementById('countsSummary').textContent = '';
        solutionCountEl.textContent = 'è§£æ³•ï¼š0ç§';
        solutionSelect.innerHTML = '';
        // åªéšè—é€‰æ‹©ä¸‹æ‹‰æ¡†ï¼Œä¿ç•™è§£æ³•æ•°é‡æ˜¾ç¤º
        solutionSelect.parentElement.style.display = 'none';
        // å±•ç¤ºç©ºæ ¼å­
        renderVis(Array.from({ length: SIZE }, () => Array.from({ length: SIZE }, () => 'o')));
        return;
      }
      
      const { solutions, selectedIndex } = resultsData;
      currentSolutions = solutions;
      const totalFree = computeFreeCells(pkg);
      
      // æ˜¾ç¤ºé€‰æ‹©ä¸‹æ‹‰æ¡†
      solutionSelect.parentElement.style.display = 'inline';
      
      // é‡å»ºé€‰é¡¹
      solutionSelect.innerHTML = '';
      solutionCountEl.textContent = `è§£æ³•ï¼š${solutions.length}ç§`;
      
      solutions.forEach((s, i) => {
        const opt = document.createElement('option');
        opt.value = String(i);
        opt.textContent = `æ–¹æ¡ˆ ${i + 1}`;
        solutionSelect.appendChild(opt);
        opt.dataset.counts = JSON.stringify(s.counts);
      });
      
      // é€‰æ‹©ä¹‹å‰ä¿å­˜çš„æ–¹æ¡ˆ
      const validIndex = Math.min(selectedIndex || 0, solutions.length - 1);
      solutionSelect.value = String(validIndex);
      
      // æ˜¾ç¤ºé€‰ä¸­çš„æ–¹æ¡ˆ
      const selectedSolution = solutions[validIndex];
      const { util, vis, idGrid } = formatResultJSGrid(selectedSolution.grid, pkg);
      utilEl.innerHTML = `åˆ©ç”¨ç‡: <strong>${(util * 100).toFixed(2)}%</strong>`;
      renderVis(vis, idGrid);
      
      const opt = solutionSelect.options[validIndex];
      if (opt && opt.dataset.counts) {
        renderCountsSummary(JSON.parse(opt.dataset.counts));
      }
    }
    
    // æ¸…ç©ºå½“å‰æ˜¾ç¤ºçš„ç»“æœ
    function clearCurrentResults() {
      utilEl.innerHTML = 'åˆ©ç”¨ç‡: --';
      visEl.innerHTML = '';
      document.getElementById('countsSummary').textContent = '';
      solutionCountEl.textContent = 'è§£æ³•ï¼š0ç§';
      solutionSelect.innerHTML = '';
      currentSolutions = [];
      // åªéšè—é€‰æ‹©ä¸‹æ‹‰æ¡†ï¼Œä¿ç•™è§£æ³•æ•°é‡æ˜¾ç¤º
      solutionSelect.parentElement.style.display = 'none';
      // æ˜¾ç¤ºç©ºçš„ç½‘æ ¼
      renderVis(Array.from({ length: SIZE }, () => Array.from({ length: SIZE }, () => 'o')));
    }
    
    // æ›´æ–°æŒ‰é’®çŠ¶æ€
    function updateCalculateButton(calculating) {
      const calculateBtn = document.getElementById('calculate');
      if (calculating) {
        calculateBtn.textContent = 'å–æ¶ˆè®¡ç®—';
        calculateBtn.classList.add('cancel');
      } else {
        calculateBtn.textContent = 'è®¡ç®—ç»“æœ';
        calculateBtn.classList.remove('cancel');
      }
    }
    
    // å–æ¶ˆå½“å‰è®¡ç®—
    function cancelCalculation() {
      if (!isCalculating) return;
      
      console.log('ç”¨æˆ·å–æ¶ˆè®¡ç®—');
      isCalculating = false;
      
      // æ¸…é™¤è¿›åº¦æ¡æ˜¾ç¤ºçš„å®šæ—¶å™¨
      if (progressTimeout) {
        clearTimeout(progressTimeout);
        progressTimeout = null;
      }
      
      // è®¾ç½®å–æ¶ˆæ ‡è®°
      if (currentCalculationPromise && currentCalculationPromise.cancelToken) {
        currentCalculationPromise.cancelToken.cancelled = true;
      }
      
      // å–æ¶ˆ Worker è®¡ç®—
      cancelWorkerCalculation();
      
      // éšè—è¿›åº¦æ¡å’Œé®ç½©
      const progressContainer = document.getElementById('progressContainer');
      const resultOverlay = document.getElementById('resultOverlay');
      progressContainer.style.display = 'none';
      resultOverlay.classList.remove('show');
      
      // æ¢å¤æŒ‰é’®çŠ¶æ€
      updateCalculateButton(false);
      
      console.log('è®¡ç®—å·²å–æ¶ˆ');
    }
    
    function requestSolve() {
      // å¦‚æœæ­£åœ¨è®¡ç®—ï¼Œåˆ™å–æ¶ˆè®¡ç®—
      if (isCalculating) {
        cancelCalculation();
        return;
      }
      
      // æ£€æŸ¥æ˜¯å¦æœ‰ç‰©å“æ•°é‡è®¾ç½®
      const hasItems = counts.some(count => count > 0);
      if (!hasItems) {
        // æ²¡æœ‰è®¾ç½®ä»»ä½•ç‰©å“æ•°é‡ï¼Œç›´æ¥æ˜¾ç¤ºç©ºç»“æœ
        clearCurrentResults();
        utilEl.innerHTML = 'åˆ©ç”¨ç‡: <strong>0.00%</strong>';
        solutionCountEl.textContent = 'è§£æ³•ï¼š0ç§';
        saveResults([]);
        return;
      }
      
      clearTimeout(solveTimer);
      solveTimer = setTimeout(() => {
        // æ ‡è®°å¼€å§‹è®¡ç®—
        isCalculating = true;
        
        // æ¸…ç©ºå½“å‰ç»“æœ
        clearCurrentResults();
        
        // æ›´æ–°æŒ‰é’®çŠ¶æ€
        updateCalculateButton(true);
        
        // è·å–è¿›åº¦æ¡å’Œé®ç½©å…ƒç´ 
        const progressContainer = document.getElementById('progressContainer');
        const progressFill = document.getElementById('progressFill');
        const progressText = document.getElementById('progressText');
        const resultOverlay = document.getElementById('resultOverlay');
        
        // åˆå§‹åŒ–è¿›åº¦æ¡çŠ¶æ€ï¼ˆä½†ä¸æ˜¾ç¤ºï¼‰
        progressFill.style.width = '0%';
        progressText.textContent = '0%';
        
        // è¿›åº¦å›è°ƒå‡½æ•°ï¼Œæ·»åŠ é˜²æŠ–å’Œå¹³æ»‘å¤„ç†
        let lastDisplayedProgress = 0;
        const updateProgress = (progress) => {
          const roundedProgress = Math.round(progress);
          // åªæœ‰å½“è¿›åº¦çœŸæ­£å¢åŠ æ—¶æ‰æ›´æ–°æ˜¾ç¤ºï¼Œé¿å…åå¤æ¨ªè·³
          if (roundedProgress > lastDisplayedProgress) {
            lastDisplayedProgress = roundedProgress;
            progressFill.style.width = `${roundedProgress}%`;
            progressText.textContent = `${roundedProgress}%`;
          }
        };
        
        // å»¶è¿Ÿ300æ¯«ç§’æ˜¾ç¤ºè¿›åº¦æ¡å’Œé®ç½©
        progressTimeout = setTimeout(() => {
          if (isCalculating) {
            progressContainer.style.display = 'flex';
            resultOverlay.classList.add('show');
          }
        }, 300);
        
        // ç«‹å³å¼€å§‹è®¡ç®—
        setTimeout(async () => {
          try {
            // åˆ›å»ºå–æ¶ˆä»¤ç‰Œ
            const cancelToken = { cancelled: false };
            
            // åˆ›å»ºè®¡ç®—Promiseå¹¶ä¿å­˜å¼•ç”¨
            currentCalculationPromise = solveWithNewArchitecture(pkg, ITEM_SHAPES, counts, updateProgress, cancelToken);
            currentCalculationPromise.cancelToken = cancelToken;
            
            // ä½¿ç”¨æ–°çš„ä¸‰é˜¶æ®µæ¶æ„è¿›è¡Œæ±‚è§£
            const { bestFilled, solutions } = await currentCalculationPromise;
            
            // è®¡ç®—å®Œæˆï¼Œå–æ¶ˆè¿›åº¦æ¡æ˜¾ç¤ºçš„å®šæ—¶å™¨
            clearTimeout(progressTimeout);
            
            // è®¡ç®—å®Œæˆåç«‹å³æ˜¾ç¤º100%
            updateProgress(100);
            
            // å¤„ç†ç»“æœï¼ˆsolutionså·²ç»åŒ…å«countsä¿¡æ¯ï¼Œæ— éœ€é‡æ–°æ¨å¯¼ï¼‰
            const totalFree = computeFreeCells(pkg);
            const seen = new Map(); // key -> {filled, grid, counts}
            const unique = [];
            
            for (const s of solutions) {
              const countsToUse = deriveCountsFromGrid(s.grid, ITEM_SHAPES.length);
              const key = countsToUse.join(',');
              if (!seen.has(key)) {
                const entry = { ...s, counts: countsToUse };
                seen.set(key, entry);
                unique.push(entry);
              }
            }
            
            currentSolutions = unique;
            
            // æ„å»ºé€‰é¡¹
            solutionSelect.innerHTML = '';
            if (unique.length === 0) {
              utilEl.innerHTML = 'åˆ©ç”¨ç‡: --';
              visEl.innerHTML = '';
              document.getElementById('countsSummary').textContent = '';
              solutionCountEl.textContent = 'è§£æ³•ï¼š0ç§';
              // åªéšè—é€‰æ‹©ä¸‹æ‹‰æ¡†ï¼Œä¿ç•™è§£æ³•æ•°é‡æ˜¾ç¤º
              solutionSelect.parentElement.style.display = 'none';
              // å±•ç¤ºç©ºæ ¼å­
              renderVis(Array.from({ length: SIZE }, () => Array.from({ length: SIZE }, () => 'o')));
              // ä¿å­˜ç©ºç»“æœ
              saveResults([]);
              return;
            }
            
            // æ˜¾ç¤ºé€‰æ‹©ä¸‹æ‹‰æ¡†
            solutionSelect.parentElement.style.display = 'inline';
            
            solutionCountEl.textContent = `è§£æ³•ï¼š${unique.length}ç§`;
            unique.forEach((s, i) => {
              const util = totalFree === 0 ? 0 : s.filled / totalFree;
              const opt = document.createElement('option');
              opt.value = String(i);
              opt.textContent = `æ–¹æ¡ˆ ${i + 1}`;
              solutionSelect.appendChild(opt);
              // Store counts for later
              opt.dataset.counts = JSON.stringify(s.counts);
            });
            
            // é»˜è®¤é€‰æ‹©ç¬¬ä¸€ä¸ªè§£å†³æ–¹æ¡ˆ
            solutionSelect.value = '0';
            const first = unique[0];
            const { util, vis, idGrid } = formatResultJSGrid(first.grid, pkg);
            utilEl.innerHTML = `åˆ©ç”¨ç‡: <strong>${(util * 100).toFixed(2)}%</strong>`;
            renderVis(vis, idGrid);
            renderCountsSummary(JSON.parse(solutionSelect.options[0].dataset.counts));
            
            // ä¿å­˜è®¡ç®—ç»“æœ
            saveResults(unique, 0);
            
            // éšè—è¿›åº¦æ¡å’Œé®ç½©
            progressContainer.style.display = 'none';
            resultOverlay.classList.remove('show');
            
          } catch (error) {
            console.error('è®¡ç®—è¿‡ç¨‹ä¸­å‡ºç°é”™è¯¯:', error);
            
            // è®¡ç®—å‡ºé”™ï¼Œå–æ¶ˆè¿›åº¦æ¡æ˜¾ç¤ºçš„å®šæ—¶å™¨
            clearTimeout(progressTimeout);
            
            // å¦‚æœæ˜¯å–æ¶ˆæ“ä½œï¼Œä¸æ˜¾ç¤ºé”™è¯¯ä¿¡æ¯
            if (error.message !== 'è®¡ç®—å·²å–æ¶ˆ') {
              utilEl.innerHTML = 'è®¡ç®—å‡ºé”™ï¼Œè¯·é‡è¯•';
            }
            
            progressContainer.style.display = 'none';
            resultOverlay.classList.remove('show');
          } finally {
            // æ¢å¤è®¡ç®—çŠ¶æ€å’ŒæŒ‰é’®
            isCalculating = false;
            updateCalculateButton(false);
            currentCalculationPromise = null;
          }
        }, 10); // çŸ­æš‚å»¶è¿Ÿè®©è¿›åº¦æ¡æ˜¾ç¤º
      }, 50);
    }

    solutionSelect.onchange = () => {
      const idx = parseInt(solutionSelect.value, 10);
      const s = currentSolutions[idx];
      const { util, vis, idGrid } = formatResultJSGrid(s.grid, pkg);
      utilEl.innerHTML = `åˆ©ç”¨ç‡: <strong>${(util * 100).toFixed(2)}%</strong>`;
      renderVis(vis, idGrid);
      const opt = solutionSelect.options[solutionSelect.selectedIndex];
      renderCountsSummary(JSON.parse(opt.dataset.counts || '[]'));
      
      // ä¿å­˜å½“å‰é€‰ä¸­çš„æ–¹æ¡ˆç´¢å¼•
      if (currentSolutions.length > 0) {
        saveResults(currentSolutions, idx);
      }
    };

    async function init() {
      loadState();
      renderGrid();
      renderShapes();
      // è½½å…¥å¹¶æ˜¾ç¤ºä¸Šæ¬¡çš„è®¡ç®—ç»“æœ
      loadAndDisplayResults();
      
      // åœ¨é¡µé¢åŠ è½½æ—¶å°±å¼€å§‹åˆå§‹åŒ– Worker æ± 
      console.log('å¼€å§‹åˆå§‹åŒ– Worker æ± ...');
      try {
        await initWorkerPool();
        console.log('Worker æ± åœ¨é¡µé¢åŠ è½½æ—¶åˆå§‹åŒ–å®Œæˆ');
      } catch (error) {
        console.warn('Worker æ± åˆå§‹åŒ–å¤±è´¥ï¼Œå°†åœ¨éœ€è¦æ—¶é‡è¯•:', error);
      }
    }
    init();
  </script>
</body>

</html>