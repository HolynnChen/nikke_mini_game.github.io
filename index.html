<!doctype html>
<html>

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>9x9 èƒŒåŒ…å †ç§¯å¯è§†åŒ–</title>
  <style>
    :root {
      --bg: #f6f8fb;
      --card-bg: #ffffff;
      --text: #1f2937;
      --muted: #6b7280;
      --primary: #3b82f6;
      --primary-700: #2563eb;
      --border: #e5e7eb;
    }

    * {
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, system-ui, Segoe UI, Roboto, sans-serif;
      margin: 0;
      min-height: 100vh;
      background: linear-gradient(180deg, #eef2ff 0%, #f8fafc 100%);
      color: var(--text);
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .page {
      width: 100%;
      max-width: 1080px;
      padding: 24px;
    }

    h2 {
      text-align: center;
      margin: 0 0 6px;
      font-weight: 700;
      letter-spacing: 0.2px;
    }

    .small {
      color: var(--muted);
      font-size: 13px;
      text-align: center;
      margin-bottom: 16px;
    }

    .container {
      display: grid;
      gap: 20px;
      grid-template-columns: 1fr 400px 1fr;
      align-items: start;
    }





    .panel {
      background: var(--card-bg);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 16px;
      box-shadow: 0 6px 24px rgba(0, 0, 0, 0.06);
    }

    .panel h3 {
      margin: 0;
      font-size: 16px;
    }

    .panel-head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      margin-bottom: 12px;
      min-height: 24px;
    }

    .panel-head .button-group {
      display: flex;
      gap: 8px;
      margin-left: auto;
    }

    .panel-head .button-group button {
      padding: 6px 10px;
      font-size: 13px;
      font-weight: 500;
    }

    .grid {
      display: grid;
      gap: 6px;
      justify-content: center;
    }

    .cell {
      width: 30px;
      height: 30px;
      display: flex;
      align-items: center;
      justify-content: center;
      border: 1px solid var(--border);
      cursor: pointer;
      user-select: none;
      border-radius: 6px;
      transition: background 0.15s, transform 0.05s;
      font-weight: 600;
    }

    .cell.block {
      background: #111827;
      color: #fff;
      border-color: #111827;
    }

    .cell.free {
      background: #ffffff;
    }

    .cell.free:hover {
      background: #f3f6ff;
    }

    .cell:active {
      transform: scale(0.98);
    }

    .resultGrid .cell {
      width: 26px;
      height: 26px;
    }

    .resultGrid .cell {
      position: relative;
    }

    .row {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      background: #f8fafc;
      border-radius: 8px;
      border: 1px solid #e2e8f0;
      min-width: 0; /* å…è®¸flexé¡¹ç›®æ”¶ç¼© */
    }

    #shapes {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 8px;
      padding: 4px;
    }



    .shape {
      display: inline-grid;
      gap: 2px;
      padding: 6px;
      background: #ffffff;
      border: 1px solid #d1d5db;
      border-radius: 6px;
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
    }


    .sq {
      width: 10px;
      height: 10px;
      border: 1px solid #cbd5e1;
      border-radius: 2px;
      background: #fff;
    }

    .sq.on {
      background: #64748b;
    }

    .controls {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
      justify-content: center;
      margin-top: 12px;
    }

    select,
    input[type="number"] {
      appearance: none;
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 6px 10px;
      font-size: 14px;
      background: #fff;
      color: var(--text);
    }

    input[type="number"] {
      width: 80px;
    }

    button {
      border: 0;
      background: var(--primary);
      color: #fff;
      padding: 8px 12px;
      border-radius: 10px;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.15s, transform 0.05s;
    }

    button:hover {
      background: var(--primary-700);
    }

    button:active {
      transform: translateY(1px);
    }

    /* å–æ¶ˆæŒ‰é’®æ ·å¼ */
    button.cancel {
      background: #dc2626;
    }

    button.cancel:hover {
      background: #b91c1c;
    }

    .util {
      display: flex;
      justify-content: center;
      align-items: baseline;
      gap: 8px;
      margin: 8px 0 12px;
    }

    .util strong {
      font-size: 20px;
      color: var(--primary-700);
    }

    .solutions {
      display: flex;
      align-items: center;
      gap: 10px;
      justify-content: center;
      margin: 8px 0;
    }

    .summary {
      margin-top: 10px;
      color: var(--muted);
      font-size: 13px;
      text-align: center;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-wrap: wrap;
      line-height: 1.4;
    }


    .progress-container {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-left: auto;
      height: 100%;
    }

    .progress-bar {
      width: 80px;
      height: 6px;
      background: #e5e7eb;
      border-radius: 3px;
      overflow: hidden;
      position: relative;
    }

    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, var(--primary) 0%, var(--primary-700) 100%);
      border-radius: 3px;
      width: 0%;
      transition: width 0.2s ease-out;
    }

    .progress-text {
      font-size: 11px;
      color: var(--muted);
      font-weight: 500;
      min-width: 28px;
      text-align: right;
    }

    .footer {
      color: var(--muted);
      font-size: 12px;
      margin-top: 14px;
      text-align: center;
    }

    .result-overlay {
      position: absolute;
      top: 50px;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(255, 255, 255, 0.9);
      backdrop-filter: blur(2px);
      display: none;
      align-items: center;
      justify-content: center;
      border-radius: 0 0 12px 12px;
      z-index: 10;
    }

    .result-overlay.show {
      display: flex;
    }

    .loading-spinner {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 16px;
    }

    .spinner {
      width: 40px;
      height: 40px;
      border: 3px solid #e5e7eb;
      border-top: 3px solid var(--primary);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .loading-text {
      color: var(--muted);
      font-size: 14px;
      font-weight: 500;
    }

    /* ç¡®ä¿ç»“æœé¢æ¿æœ‰ç›¸å¯¹å®šä½ */
    .result-panel {
      position: relative;
    }

    @media (max-width: 1200px) {
      .container {
        grid-template-columns: 1fr 1fr;
      }

      
      #shapes {
        grid-template-columns: repeat(2, minmax(0, 1fr)); /* åœ¨ä¸¤åˆ—å¸ƒå±€æ—¶ä¿æŒä¸¤åˆ— */
      }
      
      .row {
        gap: 10px; /* å¢åŠ é—´è· */
        padding: 8px 12px;
      }
      
      input[type="number"] {
        width: 70px !important; /* æ¢å¤è¾ƒå¤§çš„è¾“å…¥æ¡† */
      }
    }



    @media (max-width: 900px) {
      .container {
        grid-template-columns: 1fr;
      }

      #shapes {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }
      
      .row {
        gap: 12px;
        padding: 10px 14px;
      }
      
      input[type="number"] {
        width: 80px !important;
      }
    }



  </style>
</head>

<body>
  <div class="page">
    <h2>9x9 èƒŒåŒ…å †ç§¯å¯è§†åŒ–</h2>
    <div class="small">ç‚¹å‡»ç½‘æ ¼åˆ‡æ¢å¯ç”¨/ä¸å¯ç”¨(x)ã€‚è®¾ç½®å„å½¢çŠ¶æ•°é‡ï¼Œå®æ—¶è®¡ç®—å¹¶å±•ç¤ºæœ€ä¼˜å †ç§¯æ–¹æ¡ˆåŠåˆ©ç”¨ç‡ã€‚æœ€ä½³ç”¨é€”ï¼šå¸®ä½ å¡«ç¼ã€‚</div>

    <div class="container">
      <div class="panel">
        <h3>èƒŒåŒ… 9x9</h3>
        <div id="grid" class="grid"></div>
        <div class="controls">
          <button id="clear">é‡ç½®èƒŒåŒ…çŠ¶æ€</button>
          <button id="fill">å…¨éƒ¨å¯ç”¨</button>
        </div>
      </div>
      <div class="panel">
        <div class="panel-head">
          <h3>ç‰©ä½“æ•°é‡</h3>
          <div class="button-group">
            <button id="clearCounts">æ¸…ç©ºç‰©å“æ•°é‡</button>
            <button id="calculate">è®¡ç®—ç»“æœ</button>
          </div>
        </div>
        <div id="shapes"></div>
      </div>
      <div class="panel result-panel">
        <div class="panel-head">
          <h3>ç»“æœ</h3>
          <div class="progress-container" id="progressContainer" style="display: none;">
            <div class="progress-bar">
              <div class="progress-fill" id="progressFill"></div>
            </div>
            <span class="progress-text" id="progressText">0%</span>
          </div>
        </div>
        <div id="util" class="util">åˆ©ç”¨ç‡: --</div>
        <div class="solutions">
          <span id="solutionCount">è§£æ³•ï¼š0ç§</span>
          <label>é€‰æ‹©:
            <select id="solutionSelect"></select>
          </label>
        </div>
        <div id="vis" class="grid resultGrid"></div>
        <div id="countsSummary" class="summary"></div>
        <div class="result-overlay" id="resultOverlay">
          <div class="loading-spinner">
            <div class="spinner"></div>
            <div class="loading-text">æ­£åœ¨è®¡ç®—æœ€ä¼˜æ–¹æ¡ˆ...</div>
          </div>
        </div>
      </div>
    </div>


    <div class="footer">è¯´æ˜ï¼šç‰©ä½“ä¸å¯æ—‹è½¬ï¼›å­—æ¯è¡¨ç¤ºä¸åŒå½¢çŠ¶çš„æ‘†æ”¾ï¼›ç©ºä½™å¯ç”¨ä½ç½®æ˜¾ç¤ºä¸ºç©ºï¼Œéšœç¢æ˜¾ç¤ºä¸º xã€‚</div>
  </div>

  <script>
    const MAX = 9;
    let SIZE = 9;

    // Shapes copied from current game.py item_sharp
    const ITEM_SHAPES = [
      [[1, 0], [1, 0], [1, 0], [1, 1]],
      [[0, 1], [0, 1], [1, 1], [0, 1]],
      [[0, 0, 0, 1], [1, 1, 1, 1]],
      [[1, 1, 1, 1], [0, 1, 0, 0]],
      [[1, 1, 1], [1, 0, 0]],
      [[1, 1], [1, 1]],
      [[1, 1], [1, 0]],
      [[1], [1], [1]],
      [[1, 1, 1]],
      [[1], [1]],
      [[1]]
    ];

    let counts = ITEM_SHAPES.map(_ => 0);
    let pkg = Array.from({ length: SIZE }, (_, i) => Array.from({ length: SIZE }, (_, j) => i >= 2 && i <= 6 && j >= 3 && j <= 5 ? 'o' : 'x'));

    // Persist/restore state -------------------------------------------------
    const LS_COUNTS = 'packing_counts_v1';
    const LS_PKG = 'packing_pkg_v1';
    const LS_RESULTS = 'packing_results_v1';
    
    function saveState() {
      try {
        localStorage.setItem(LS_COUNTS, JSON.stringify(counts));
        localStorage.setItem(LS_PKG, JSON.stringify(pkg));
      } catch (e) { /* ignore quota errors */ }
    }
    
    function saveResults(solutions, selectedIndex = 0) {
      try {
        const resultsData = {
          solutions: solutions,
          selectedIndex: selectedIndex,
          timestamp: Date.now()
        };
        localStorage.setItem(LS_RESULTS, JSON.stringify(resultsData));
      } catch (e) { /* ignore quota errors */ }
    }
    
    function loadState() {
      try {
        const c = JSON.parse(localStorage.getItem(LS_COUNTS) || 'null');
        const p = JSON.parse(localStorage.getItem(LS_PKG) || 'null');
        if (Array.isArray(c) && c.length === ITEM_SHAPES.length && c.every(n => Number.isInteger(n) && n >= 0)) {
          counts = c.slice();
        }
        if (Array.isArray(p) && p.length === SIZE && p.every(r => Array.isArray(r) && r.length === SIZE)) {
          pkg = p.map(r => r.map(v => (v === 'x' ? 'x' : 'o')));
        }
      } catch (e) { /* ignore parse errors */ }
    }
    
    function loadResults() {
      try {
        const resultsData = JSON.parse(localStorage.getItem(LS_RESULTS) || 'null');
        if (resultsData && Array.isArray(resultsData.solutions) && resultsData.solutions.length > 0) {
          return resultsData;
        }
      } catch (e) { /* ignore parse errors */ }
      return null;
    }

    const gridEl = document.getElementById('grid');
    const visEl = document.getElementById('vis');
    const utilEl = document.getElementById('util');
    const shapesEl = document.getElementById('shapes');
    const clearBtn = document.getElementById('clear');
    const fillBtn = document.getElementById('fill');
    const clearCountsBtn = document.getElementById('clearCounts');
    const calculateBtn = document.getElementById('calculate');

    clearBtn.onclick = () => {
      pkg = Array.from({ length: SIZE }, (_, i) => Array.from({ length: SIZE }, (_, j) => i >= 2 && i <= 6 && j >= 3 && j <= 5 ? 'o' : 'x'));
      renderGrid();
      saveState();
    };
    fillBtn.onclick = () => {
      pkg = Array.from({ length: SIZE }, () => Array.from({ length: SIZE }, () => 'o'));
      renderGrid();
      saveState();
    };
    clearCountsBtn.onclick = () => {
      counts = counts.map(() => 0);
      document.querySelectorAll('#shapes input[type="number"]').forEach(inp => inp.value = '0');
      saveState();
    };
    calculateBtn.onclick = () => {
      requestSolve();
    };

    function renderGrid() {
      gridEl.innerHTML = '';
      gridEl.style.gridTemplateColumns = `repeat(${SIZE}, 28px)`;
      for (let r = 0; r < SIZE; r++) {
        for (let c = 0; c < SIZE; c++) {
          const div = document.createElement('div');
          const v = pkg[r][c];
          div.className = 'cell ' + (v === 'x' ? 'block' : 'free');
          div.textContent = v === 'x' ? 'x' : '';
          div.onclick = () => {
            pkg[r][c] = pkg[r][c] === 'x' ? 'o' : 'x';
            renderGrid();
            saveState();
          };
          gridEl.appendChild(div);
        }
      }
    }

    function renderShapes() {
      shapesEl.innerHTML = '';
      ITEM_SHAPES.forEach((s, idx) => {
        const row = document.createElement('div');
        row.className = 'row';

        const label = document.createElement('div');
        label.textContent = `${String.fromCharCode(65 + (idx % 26))}`;
        label.style.fontWeight = '600';
        label.style.fontSize = '14px';
        label.style.color = '#374151';
        label.style.minWidth = '18px';
        label.style.flexShrink = '0';

        label.style.textAlign = 'center';

        const preview = document.createElement('div');

        preview.className = 'shape';
        preview.style.gridTemplateColumns = `repeat(${s[0].length}, 10px)`;
        s.forEach(rr => rr.forEach(cc => {
          const sq = document.createElement('div');
          sq.className = 'sq ' + (cc ? 'on' : '');
          preview.appendChild(sq);
        }));

        const input = document.createElement('input');
        input.type = 'number';
        input.min = '0';
        input.value = counts[idx];
        input.style.width = '60px';
        input.style.minWidth = '50px';
        input.style.maxWidth = '70px';
        input.style.textAlign = 'center';
        input.style.fontWeight = '500';
        input.style.flexShrink = '0'; /* é˜²æ­¢è¾“å…¥æ¡†è¢«è¿‡åº¦å‹ç¼© */

        input.oninput = () => {
          counts[idx] = Math.max(0, parseInt(input.value || '0', 10));
          saveState();
        };


        row.appendChild(label);
        row.appendChild(preview);
        row.appendChild(input);
        shapesEl.appendChild(row);
      });
    }

    function area(shape) { return shape.flat().reduce((a, b) => a + (b ? 1 : 0), 0); }

    // Solver (ported to JS) ---------------------------------------------
    function computeFreeCells(grid) {
      let n = 0; for (const row of grid) for (const c of row) if (c === 'o') n++; return n;
    }
    function countFilled(grid) {
      let n = 0; for (const row of grid) for (const c of row) if (Array.isArray(c)) n++; return n;
    }
    function deriveCountsFromGrid(grid, shapesLen) {
      // Marks are ['i', idx, k]; count how many marks per idx
      const counts = Array(shapesLen).fill(0);
      for (const row of grid) {
        for (const c of row) {
          if (Array.isArray(c) && c[0] === 'i') counts[c[1]] += 1;
        }
      }
      // Each item contributes area equal to item shape area; to get piece counts, divide by area
      return counts.map((cells, idx) => {
        const areaVal = area(ITEM_SHAPES[idx]);
        return areaVal > 0 ? Math.round(cells / areaVal) : 0;
      });
    }

    // æ–°æ¶æ„ï¼šä¸‰é˜¶æ®µæ±‚è§£ç³»ç»Ÿ
    let workerPool = [];
    let currentSolveId = 0;
    const MAX_WORKERS = navigator.hardwareConcurrency || 4; // ä½¿ç”¨CPUæ ¸æ•°ï¼Œé»˜è®¤4ä¸ª
    let isCalculating = false; // æ ‡è®°æ˜¯å¦æ­£åœ¨è®¡ç®—
    let currentCalculationPromise = null; // å½“å‰è®¡ç®—çš„Promiseï¼Œç”¨äºå–æ¶ˆ
    
    // ç¬¬ä¸€é˜¶æ®µï¼šç”Ÿæˆæ‰€æœ‰é¥±å’Œçš„ç‰©å“ç»„åˆï¼ˆæ— æ³•å†æ·»åŠ ä»»ä½•ç‰©å“çš„ç»„åˆï¼‰
    function generateValidCombinations(shapes, maxCounts, freeArea) {
      const validCombinations = [];
      
      // é¢„è®¡ç®—æ¯ä¸ªç‰©å“çš„é¢ç§¯
      const shapeAreas = shapes.map(shape => area(shape));
      
      function isSaturated(combination, currentArea) {
        // æ£€æŸ¥æ˜¯å¦è¿˜èƒ½æ·»åŠ ä»»ä½•ç‰©å“
        for (let i = 0; i < shapes.length; i++) {
          if (combination[i] < maxCounts[i] && currentArea + shapeAreas[i] <= freeArea) {
            return false; // è¿˜èƒ½æ·»åŠ ç¬¬iç§ç‰©å“
          }
        }
        return true; // æ— æ³•å†æ·»åŠ ä»»ä½•ç‰©å“ï¼Œç»„åˆå·²é¥±å’Œ
      }
      
      function backtrack(index, currentCombination, currentArea) {
        if (currentArea > freeArea) return; // å‰ªæï¼šé¢ç§¯è¶…é™
        
        if (index === shapes.length) {
          if (currentArea > 0 && isSaturated(currentCombination, currentArea)) {
            // åªä¿ç•™é¥±å’Œçš„ç»„åˆï¼ˆæ— æ³•å†æ·»åŠ ä»»ä½•ç‰©å“ï¼‰
            validCombinations.push([...currentCombination]);
          }
          return;
        }
        
        const shapeArea = shapeAreas[index];
        const maxPossible = Math.floor((freeArea - currentArea) / shapeArea);
        const actualMax = Math.min(maxCounts[index], maxPossible);
        
        for (let count = 0; count <= actualMax; count++) {
          currentCombination[index] = count;
          backtrack(index + 1, currentCombination, currentArea + count * shapeArea);
        }
      }
      
      backtrack(0, new Array(shapes.length).fill(0), 0);
      return validCombinations;
    }
    
    // åˆ›å»ºå•ä¸ªWorkerç”¨äºå¤„ç†ç‰¹å®šç»„åˆ
    function createCombinationWorker() {
      const workerCode = `
const ITEM_SHAPES = [
    [[1, 1, 1], [1, 0, 0]],
    [[0, 0, 0, 1], [1, 1, 1, 1]],
    [[1, 1, 1, 1], [0, 1, 0, 0]],
    [[1, 1], [1, 0]],
    [[1, 1], [1, 1]],
    [[1], [1]],
    [[1], [1], [1]],
    [[1, 0], [1, 0], [1, 0], [1, 1]],
    [[0, 1], [0, 1], [1, 1], [0, 1]],
    [[1, 1, 1]],
    [[1]]
];

const MAX_SOLUTIONS_PER_WORKER = 10; // é™åˆ¶æ¯ä¸ªWorkeræœ€å¤šä¿ç•™10ä¸ªè§£å†³æ–¹æ¡ˆ

function area(shape) { return shape.flat().reduce((a, b) => a + (b ? 1 : 0), 0); }

function computeFreeCells(grid) {
    let n = 0; for (const row of grid) for (const c of row) if (c === 'o') n++; return n;
}

function firstFreeCell(grid,r,c) {
    for (let i = r; i < grid.length; i++) {
        for (let j = 0; j < grid[0].length; j++) {
          if (i === r && j < c) continue;
          // if (grid[i][j] === 'o') return [i, j];
          return [i, j];
        }
    }
    return null;
}

function canPlaceWithAnchor(grid, shape, r, c) {
    const rows = grid.length, cols = grid[0].length;
    const sh = shape.length, sw = shape[0].length;
    for (let i = 0; i < sh; i++) {
        for (let j = 0; j < sw; j++) {
            if (shape[i][j] !== 1) continue;
            const gr = r + i;
            const gc = c + j;
            if (gr < 0 || gc < 0 || gr >= rows || gc >= cols) return false;
            if (grid[gr][gc] !== 'o') return false;
        }
    }
    return true;
}

function placeWithAnchor(grid, shape, r, c, mark) {
    for (let i = 0; i < shape.length; i++) {
        for (let j = 0; j < shape[0].length; j++) {
            if (shape[i][j] !== 1) continue;
            const gr = r + i;
            const gc = c + j;
            grid[gr][gc] = mark;
        }
    }
}

function countFilled(grid) {
    let n = 0; for (const row of grid) for (const c of row) if (Array.isArray(c)) n++; return n;
}

// å‹ç¼©ç½‘æ ¼è¡¨ç¤ºï¼šåªå­˜å‚¨ç‰©å“æ”¾ç½®ä¿¡æ¯ï¼Œè€Œä¸æ˜¯å®Œæ•´ç½‘æ ¼
function compressGrid(grid, originalGrid) {
    const placements = [];
    for (let r = 0; r < grid.length; r++) {
        for (let c = 0; c < grid[0].length; c++) {
            const cell = grid[r][c];
            if (Array.isArray(cell) && cell[0] === 'i') {
                placements.push({
                    r: r,
                    c: c,
                    idx: cell[1],
                    inst: cell[2]
                });
            }
        }
    }
    return {
        placements: placements,
        rows: grid.length,
        cols: grid[0].length
    };
}

// ä»å‹ç¼©æ ¼å¼é‡å»ºç½‘æ ¼ï¼ˆä»…åœ¨éœ€è¦æ—¶ä½¿ç”¨ï¼‰
function decompressGrid(compressed, originalGrid) {
    const grid = originalGrid.map(r => r.slice());
    for (const p of compressed.placements) {
        grid[p.r][p.c] = ['i', p.idx, p.inst];
    }
    return grid;
}

// è®¡ç®—ç‰©å“ä½¿ç”¨æ•°é‡ï¼ˆç”¨äºå»é‡ï¼‰
function calculateUsedCounts(placements, shapesLength) {
    const counts = Array(shapesLength).fill(0);
    const instanceCounts = new Map();

    for (const p of placements) {
        const key = p.idx + '_' + p.inst;
        if (!instanceCounts.has(key)) {
            instanceCounts.set(key, 0);
            counts[p.idx]++;
        }
    }
    return counts;
}

// ç”Ÿæˆè§£å†³æ–¹æ¡ˆçš„å”¯ä¸€é”®ï¼ˆåŸºäºç‰©å“ä½¿ç”¨æƒ…å†µï¼‰
function getSolutionKey(placements, shapesLength) {
    const usedCounts = calculateUsedCounts(placements, shapesLength);
    return usedCounts.join(',');
}

// é’ˆå¯¹å•ä¸ªç»„åˆçš„ä¼˜åŒ–æ±‚è§£å™¨
function solveCombination(grid, shapes, counts, combinationIndex, totalCombinations) {
    let bestFilled = -1;
    const solutionMap = new Map(); // ç”¨äºå»é‡ï¼škey -> compressed solution
    const rows = grid.length, cols = grid[0].length;

    function cloneGrid(g) { return g.map(r => r.slice()); }

    function backtrack(cur,old_r,old_c, remaining, placedCounter, is_skip = false) {
        // æ£€æŸ¥æ˜¯å¦éœ€è¦å–æ¶ˆè®¡ç®—
        if (shouldCancel) {
            return;
        }

        const filled = countFilled(cur);
        let remainingFree = 0;
        for (let i = old_r; i < cur.length; i++) {
          for (let j = 0; j < cur[0].length; j++) {
            if (i === old_r && j < old_c) continue;
            if (cur[i][j] === 'o') remainingFree++;
          }
        }
        let remainingTotal = remaining.reduce((a, b, idx) => a + b*area(shapes[idx]), 0);
        let remainingMin = Math.min(remainingFree, remainingTotal);
        // å‰ªæï¼šå¦‚æœå½“å‰å¡«å……æ•°åŠ ä¸Šå‰©ä½™ç©ºé—´éƒ½ä¸å¦‚æœ€ä½³ç»“æœï¼Œç›´æ¥è¿”å›
        if (filled + remainingFree < bestFilled) return;
        if (is_skip && (filled + remainingMin <= bestFilled)) return;

        const next = firstFreeCell(cur,old_r,old_c);
        if (!next || !remaining.some(n=>n>0)) {
            if (filled >= bestFilled) {
                const compressed = compressGrid(cur, grid);
                const solutionKey = getSolutionKey(compressed.placements, shapes.length);

                if (filled > bestFilled) {
                    // æ‰¾åˆ°æ›´å¥½çš„è§£å†³æ–¹æ¡ˆï¼Œæ¸…ç©ºä¹‹å‰çš„ç»“æœ
                    bestFilled = filled;
                    solutionMap.clear();
                    solutionMap.set(solutionKey, { filled, compressed });
                } else if (filled === bestFilled && !solutionMap.has(solutionKey)) {
                    // ç›¸åŒè´¨é‡çš„æ–°è§£å†³æ–¹æ¡ˆ
                    solutionMap.set(solutionKey, { filled, compressed });

                    // é™åˆ¶è§£å†³æ–¹æ¡ˆæ•°é‡ï¼Œé˜²æ­¢å†…å­˜æº¢å‡º
                    if (solutionMap.size > MAX_SOLUTIONS_PER_WORKER) {
                        // éšæœºç§»é™¤ä¸€äº›è§£å†³æ–¹æ¡ˆï¼Œä¿æŒå¤šæ ·æ€§
                        const keys = Array.from(solutionMap.keys());
                        const toRemove = keys.slice(0, Math.floor(MAX_SOLUTIONS_PER_WORKER / 2));
                        toRemove.forEach(key => solutionMap.delete(key));
                    }
                }
            }
            return;
        }

        const [r, c] = next;
        let triedPlacement = false;

        for (const idx in remaining) {
            if(remaining[idx] <= 0) continue;
            const shape = shapes[idx];
            if (!canPlaceWithAnchor(cur, shape, r, c)) continue;

            triedPlacement = true;
            const mark = ['i', idx, placedCounter[idx]];
            placeWithAnchor(cur, shape, r, c, mark);
            remaining[idx] -= 1;
            placedCounter[idx] += 1;

            backtrack(cur,r,c, remaining, placedCounter);

            placeWithAnchor(cur, shape, r, c, 'o');
            remaining[idx] += 1;
            placedCounter[idx] -= 1;
        }
        backtrack(cur,r,c+1, remaining, placedCounter, !triedPlacement);
    }
    backtrack(grid.map(r => r.slice()),0,0, counts.slice(), Array(counts.length).fill(0));

    // è½¬æ¢å‹ç¼©çš„è§£å†³æ–¹æ¡ˆä¸ºæœ€ç»ˆæ ¼å¼
    const solutions = Array.from(solutionMap.values()).map(sol => ({
        filled: sol.filled,
        compressed: sol.compressed
    }));

    return {
        bestFilled,
        solutions,
        combinationIndex
    };
}

let currentSolveId = null;
let shouldCancel = false;

self.onmessage = function (e) {
    const { type, grid, shapes, counts, combinationIndex, totalCombinations, solveId } = e.data;

    if (type === 'solveCombination') {
        currentSolveId = solveId;
        shouldCancel = false;

        try {
            const result = solveCombination(grid, shapes, counts, combinationIndex, totalCombinations);

            // æ£€æŸ¥æ˜¯å¦åœ¨è®¡ç®—è¿‡ç¨‹ä¸­è¢«å–æ¶ˆ
            if (shouldCancel && currentSolveId === solveId) {
                self.postMessage({
                    type: 'result',
                    result: {
                        bestFilled: -1,
                        solutions: [],
                        combinationIndex: combinationIndex,
                        counts: counts,
                        cancelled: true
                    },
                    solveId
                });
                return;
            }

            // åªä¼ è¾“å‹ç¼©çš„è§£å†³æ–¹æ¡ˆï¼Œå‡å°‘æ•°æ®ä¼ è¾“é‡
            const compactResult = {
                bestFilled: result.bestFilled,
                solutions: result.solutions, // å·²ç»æ˜¯å‹ç¼©æ ¼å¼
                combinationIndex: result.combinationIndex,
                counts: result.counts
            };

            self.postMessage({ type: 'result', result: compactResult, solveId });
        } catch (error) {
            console.log(error)
            self.postMessage({ type: 'error', error: error.message, solveId });
        }
    } else if (type === 'cancel') {
        if (currentSolveId === solveId) {
            shouldCancel = true;
            console.log('Workeræ”¶åˆ°å–æ¶ˆä¿¡å·ï¼ŒsolveId: ' + solveId);
        }
    }
};
      `;
      
      const blob = new Blob([workerCode], { type: 'application/javascript' });
      return new Worker(URL.createObjectURL(blob));
    }
    
    // Workeræ± ç®¡ç†
    function initWorkerPool() {
      // æ¸…ç†ç°æœ‰Worker
      workerPool.forEach(worker => worker.terminate());
      workerPool = [];
      
      // åˆ›å»ºæ–°çš„Workeræ± 
      for (let i = 0; i < MAX_WORKERS; i++) {
        workerPool.push(createCombinationWorker());
      }
    }
    
    // ç»ˆæ­¢æ‰€æœ‰Worker
    function terminateAllWorkers() {
      workerPool.forEach(worker => worker.terminate());
      workerPool = [];
      console.log('æ‰€æœ‰Workerå·²ç»ˆæ­¢');
    }
    
    // è¾…åŠ©å‡½æ•°ï¼šæ£€æŸ¥ç»„åˆAæ˜¯å¦æ˜¯ç»„åˆBçš„å­é›†
    function isSubset(smaller, larger) {
      return smaller.every((count, idx) => count <= larger[idx]);
    }
    
    // è¾…åŠ©å‡½æ•°ï¼šè®¡ç®—ç»„åˆçš„æ€»é¢ç§¯
    function getCombinationArea(combination, shapes) {
      return combination.reduce((total, count, idx) => {
        return total + count * area(shapes[idx]);
      }, 0);
    }
    
    // æ–°çš„ä¸‰é˜¶æ®µæ±‚è§£æ¶æ„
    async function solveWithNewArchitecture(grid, shapes, counts, progressCallback, cancelToken) {
      const freeArea = computeFreeCells(grid);
      
      // æ£€æŸ¥æ˜¯å¦å·²å–æ¶ˆ
      if (cancelToken && cancelToken.cancelled) {
        throw new Error('è®¡ç®—å·²å–æ¶ˆ');
      }
      
      // ç¬¬ä¸€é˜¶æ®µï¼šç”Ÿæˆæ‰€æœ‰æœ‰æ•ˆç»„åˆ
      console.log('ç¬¬ä¸€é˜¶æ®µï¼šç”Ÿæˆæœ‰æ•ˆç‰©å“ç»„åˆ...');
      const validCombinations = generateValidCombinations(shapes, counts, freeArea);
      console.log(`æ‰¾åˆ° ${validCombinations.length} ä¸ªæœ‰æ•ˆç»„åˆ`);
      
      if (validCombinations.length === 0) {
        return { bestFilled: 0, solutions: [] };
      }
      
      // å†æ¬¡æ£€æŸ¥æ˜¯å¦å·²å–æ¶ˆ
      if (cancelToken && cancelToken.cancelled) {
        throw new Error('è®¡ç®—å·²å–æ¶ˆ');
      }
      
      // æŒ‰é¢ç§¯ä»å¤§åˆ°å°æ’åºç»„åˆï¼Œä¼˜å…ˆè®¡ç®—å¤§é¢ç§¯ç»„åˆ
      validCombinations.sort((a, b) => {
        const areaA = getCombinationArea(a, shapes);
        const areaB = getCombinationArea(b, shapes);
        return areaB - areaA;
      });
      
      // åˆå§‹åŒ–Workeræ± 
      if (workerPool.length === 0) {
        initWorkerPool();
        console.log(`åˆå§‹åŒ–Workeræ± ï¼šä½¿ç”¨ ${MAX_WORKERS} ä¸ªWorkerï¼ˆCPUæ ¸æ•°ï¼š${navigator.hardwareConcurrency || 'æœªçŸ¥'}ï¼‰`);
      }
      
      // ç¬¬äºŒé˜¶æ®µï¼šå¹¶è¡Œè®¡ç®—æ¯ä¸ªç»„åˆçš„æœ€ä¼˜æ”¾ç½®ï¼ˆå¸¦å­é›†å‰ªæï¼‰
      console.log('ç¬¬äºŒé˜¶æ®µï¼šå¹¶è¡Œè®¡ç®—æœ€ä¼˜æ”¾ç½®æ–¹æ¡ˆ...');
      const solveId = ++currentSolveId;
      
      // ç”¨äºè·Ÿè¸ªå½“å‰æœ€ä½³ç»„åˆï¼Œå®ç°åŠ¨æ€å‰ªæ
      let currentBestCombination = null;
      let currentBestFilled = -1;
      
      // åˆ†æ‰¹å¤„ç†ç»„åˆï¼Œå®ç°åŠ¨æ€å‰ªæ
      const batchSize = Math.min(MAX_WORKERS * 2, validCombinations.length);
      const allResults = [];
      let processedCount = 0;
      let skippedCount = 0;
      
      for (let batchStart = 0; batchStart < validCombinations.length; batchStart += batchSize) {
        // æ£€æŸ¥æ˜¯å¦å·²å–æ¶ˆ
        if (cancelToken && cancelToken.cancelled) {
          throw new Error('è®¡ç®—å·²å–æ¶ˆ');
        }
        
        const batchEnd = Math.min(batchStart + batchSize, validCombinations.length);
        const batch = validCombinations.slice(batchStart, batchEnd);
        
        // å¯¹å½“å‰æ‰¹æ¬¡åº”ç”¨å¤šé‡å‰ªæç­–ç•¥
        const filteredBatch = [];
        for (let i = 0; i < batch.length; i++) {
          const combination = batch[i];
          const globalIndex = batchStart + i;
          let shouldSkip = false;
          let skipReason = '';
          
          // å‰ªæç­–ç•¥1ï¼šå­é›†å‰ªæ - å¦‚æœå½“å‰ç»„åˆæ˜¯å·²çŸ¥æœ€ä½³ç»„åˆçš„å­é›†ï¼Œåˆ™è·³è¿‡
          if (currentBestCombination && 
              isSubset(combination, currentBestCombination) && 
              !combination.every((c, idx) => c === currentBestCombination[idx])) {
            shouldSkip = true;
            skipReason = 'æ˜¯æœ€ä½³ç»„åˆçš„å­é›†';
          }
          
          // å‰ªæç­–ç•¥2ï¼šé¢ç§¯å‰ªæ - å¦‚æœç»„åˆçš„ç†è®ºæœ€å¤§é¢ç§¯å°äºå·²çŸ¥æœ€ä¼˜å¡«å……æ•°ï¼Œåˆ™è·³è¿‡
          if (!shouldSkip && currentBestFilled > 0) {
            const theoreticalMaxArea = getCombinationArea(combination, shapes);
            if (theoreticalMaxArea < currentBestFilled) {
              shouldSkip = true;
              skipReason = `ç†è®ºæœ€å¤§é¢ç§¯${theoreticalMaxArea} < å·²çŸ¥æœ€ä¼˜${currentBestFilled}`;
            }
          }
          
          if (shouldSkip) {
            // console.log(`å‰ªæï¼šè·³è¿‡ç»„åˆ ${globalIndex + 1}ï¼ˆ${skipReason}ï¼‰`);
            skippedCount++;
            processedCount++;
            
            // æ›´æ–°è¿›åº¦
            const progress = (processedCount / validCombinations.length) * 100;
            if (progressCallback) {
              progressCallback(progress);
            }
            continue;
          }
          
          filteredBatch.push({ combination, originalIndex: globalIndex });
        }
        
        if (filteredBatch.length === 0) continue;
        
        // è·Ÿè¸ªå½“å‰æ‰¹æ¬¡çš„Workerå’Œç»„åˆä¿¡æ¯
        const activeBatchWorkers = new Map(); // workerIndex -> { combination, promise, resolve, reject }
        
        // å¹¶è¡Œå¤„ç†å½“å‰æ‰¹æ¬¡
        const batchPromises = filteredBatch.map(({ combination, originalIndex }) => {
          return new Promise((resolve, reject) => {
            const workerIndex = originalIndex % workerPool.length;
            const worker = workerPool[workerIndex];
            
            // è®°å½•å½“å‰Workerçš„ä»»åŠ¡ä¿¡æ¯
            activeBatchWorkers.set(workerIndex, { 
              combination, 
              originalIndex,
              resolve, 
              reject,
              theoreticalMaxArea: getCombinationArea(combination, shapes)
            });
            
            const handleMessage = (e) => {
              const { type, result, error, solveId: msgSolveId } = e.data;
              
              if (msgSolveId !== solveId) return;
              
              if (type === 'result') {
                worker.removeEventListener('message', handleMessage);
                
                // æ£€æŸ¥è¿™ä¸ªWorkeræ˜¯å¦å·²ç»è¢«æ ‡è®°ä¸ºå–æ¶ˆï¼Œå¦‚æœæ˜¯åˆ™ä¸é‡å¤è®¡æ•°
                const workerInfo = activeBatchWorkers.get(workerIndex);
                const wasAlreadyCancelled = workerInfo && workerInfo.cancelled;
                
                activeBatchWorkers.delete(workerIndex);
                
                // æ›´æ–°å½“å‰æœ€ä½³ç»„åˆï¼ˆç”¨äºåç»­å‰ªæï¼‰
                if (result.bestFilled > currentBestFilled) {
                  const oldBestFilled = currentBestFilled;
                  currentBestFilled = result.bestFilled;
                  console.log(JSON.parse(JSON.stringify(result)))
                  console.log(`ğŸ¯ æ›´æ–°å…¨å±€æœ€ä¼˜è§£ï¼šå¡«å……æ•° ${oldBestFilled} â†’ ${currentBestFilled}`);
                  
                  // ç«‹å³å–æ¶ˆå½“å‰æ‰¹æ¬¡ä¸­ç†è®ºä¸Šä¸å¯èƒ½è¶…è¶Šæ–°æœ€ä¼˜è§£çš„Worker
                  let cancelledWorkers = 0;
                  for (const [wIdx, workerInfo] of activeBatchWorkers.entries()) {
                    if (workerInfo.theoreticalMaxArea < currentBestFilled) {
                      console.log(`ğŸš« å–æ¶ˆWorker ${wIdx}ï¼šç†è®ºæœ€å¤§é¢ç§¯${workerInfo.theoreticalMaxArea} < å½“å‰æœ€ä¼˜${currentBestFilled}`);
                      
                      // å‘é€å–æ¶ˆæ¶ˆæ¯ç»™Worker
                      workerPool[wIdx].postMessage({
                        type: 'cancel',
                        solveId: solveId
                      });
                      
                      // æ ‡è®°Workerä¸ºå·²å–æ¶ˆï¼Œé¿å…é‡å¤è®¡æ•°
                      workerInfo.cancelled = true;
                      
                      // ç«‹å³resolveè¿™ä¸ªPromiseï¼Œæ ‡è®°ä¸ºè¢«å–æ¶ˆ
                      workerInfo.resolve({
                        bestFilled: -1,
                        solutions: [],
                        combinationIndex: workerInfo.originalIndex,
                        counts: workerInfo.combination,
                        cancelled: true
                      });
                      
                      activeBatchWorkers.delete(wIdx);
                      cancelledWorkers++;
                      
                      // è¢«å–æ¶ˆçš„Workeréœ€è¦åœ¨è¿™é‡Œè®¡æ•°ï¼Œå› ä¸ºå®ƒä»¬ä¸ä¼šè§¦å‘æ­£å¸¸çš„handleMessage
                      processedCount++;
                      
                      // æ›´æ–°è¿›åº¦
                      const progress = (processedCount / validCombinations.length) * 100;
                      if (progressCallback) {
                        progressCallback(progress);
                      }
                    }
                  }
                  
                  if (cancelledWorkers > 0) {
                    console.log(`âš¡ å·²å–æ¶ˆ ${cancelledWorkers} ä¸ªæ— æ•ˆWorkerï¼ŒèŠ‚çœè®¡ç®—èµ„æº`);
                  }
                  
                  // è®¡ç®—å› ä¸ºè¿™ä¸ªæ–°çš„æœ€ä¼˜è§£è€Œå¯ä»¥è·³è¿‡çš„å‰©ä½™ç»„åˆæ•°é‡
                  let canSkipCount = 0;
                  for (let futureIdx = batchStart + filteredBatch.length; futureIdx < validCombinations.length; futureIdx++) {
                    const futureCombination = validCombinations[futureIdx];
                    const futureArea = getCombinationArea(futureCombination, shapes);
                    if (futureArea < currentBestFilled) {
                      canSkipCount++;
                    }
                  }
                  if (canSkipCount > 0) {
                    console.log(`âš¡ æ–°æœ€ä¼˜è§£å°†ä½¿åç»­ ${canSkipCount} ä¸ªç»„åˆå¯è¢«å‰ªæ`);
                  }
                }
                
                resolve(result);
                
                // åªæœ‰åœ¨Workeræ²¡æœ‰è¢«é¢„å…ˆå–æ¶ˆçš„æƒ…å†µä¸‹æ‰å¢åŠ è®¡æ•°
                // è¢«å–æ¶ˆçš„Workerå·²ç»åœ¨åŠ¨æ€å–æ¶ˆæ—¶è®¡æ•°äº†ï¼Œè¿™é‡Œä¸å†é‡å¤è®¡æ•°
                if (!wasAlreadyCancelled && !result.cancelled) {
                  processedCount++;
                  // æ›´æ–°è¿›åº¦
                  const progress = (processedCount / validCombinations.length) * 100;
                  if (progressCallback) {
                    progressCallback(progress);
                  }
                }
              } else if (type === 'error') {
                worker.removeEventListener('message', handleMessage);
                
                // æ£€æŸ¥è¿™ä¸ªWorkeræ˜¯å¦å·²ç»è¢«æ ‡è®°ä¸ºå–æ¶ˆ
                const workerInfo = activeBatchWorkers.get(workerIndex);
                const wasAlreadyCancelled = workerInfo && workerInfo.cancelled;
                
                activeBatchWorkers.delete(workerIndex);
                
                // åªæœ‰åœ¨Workeræ²¡æœ‰è¢«é¢„å…ˆå–æ¶ˆçš„æƒ…å†µä¸‹æ‰å¢åŠ è®¡æ•°
                // è¢«å–æ¶ˆçš„Workerå·²ç»åœ¨åŠ¨æ€å–æ¶ˆæ—¶è®¡æ•°äº†ï¼Œè¿™é‡Œä¸å†é‡å¤è®¡æ•°
                if (!wasAlreadyCancelled) {
                  processedCount++;
                  // æ›´æ–°è¿›åº¦
                  const progress = (processedCount / validCombinations.length) * 100;
                  if (progressCallback) {
                    progressCallback(progress);
                  }
                }
                
                reject(new Error(error));
              }
            };
            
            worker.addEventListener('message', handleMessage);
            
            worker.postMessage({
              type: 'solveCombination',
              grid: grid,
              shapes: shapes,
              counts: combination,
              combinationIndex: originalIndex,
              totalCombinations: validCombinations.length,
              solveId: solveId
            });
          });
        });
        
        // ç­‰å¾…å½“å‰æ‰¹æ¬¡å®Œæˆ
        const batchResults = await Promise.allSettled(batchPromises);
        
        // æ£€æŸ¥æ˜¯å¦å·²å–æ¶ˆ
        if (cancelToken && cancelToken.cancelled) {
          throw new Error('è®¡ç®—å·²å–æ¶ˆ');
        }
        
        allResults.push(...batchResults);
      }
      
      const actualCalculated = validCombinations.length - skippedCount;
      const pruningEfficiency = validCombinations.length > 0 ? (skippedCount / validCombinations.length * 100).toFixed(1) : '0.0';
      console.log(`ğŸ“Š å‰ªæç»Ÿè®¡ï¼šæ€»ç»„åˆ ${validCombinations.length}ï¼Œè·³è¿‡ ${skippedCount} (${pruningEfficiency}%)ï¼Œå®é™…è®¡ç®— ${actualCalculated}`);
      
      // ç¬¬ä¸‰é˜¶æ®µï¼šæ±‡æ€»æœ€ä¼˜ç»“æœ
      console.log('ç¬¬ä¸‰é˜¶æ®µï¼šæ±‡æ€»æœ€ä¼˜ç»“æœ...');
      const successfulResults = allResults
        .filter(r => r.status === 'fulfilled' && r.value.solutions.length > 0 && !r.value.cancelled)
        .map(r => r.value);
      
      const cancelledResults = allResults
        .filter(r => r.status === 'fulfilled' && r.value.cancelled)
        .length;
      
      if (cancelledResults > 0) {
        console.log(`ğŸ“Š ä¼˜åŒ–ç»Ÿè®¡ï¼šæˆåŠŸå–æ¶ˆ ${cancelledResults} ä¸ªæ— æ•ˆWorkerï¼ŒèŠ‚çœè®¡ç®—èµ„æº`);
      }
      
      if (successfulResults.length === 0) {
        return { bestFilled: 0, solutions: [] };
      }
      
      // æ‰¾åˆ°å…¨å±€æœ€ä¼˜å¡«å……æ•°
      const globalBestFilled = Math.max(...successfulResults.map(r => r.bestFilled));
      
      // è§£å‹ç¼©å‡½æ•°ï¼ˆåœ¨ä¸»çº¿ç¨‹ä¸­ï¼‰
      function decompressGridInMain(compressed, originalGrid) {
        const grid = originalGrid.map(r => r.slice());
        for (const p of compressed.placements) {
          grid[p.r][p.c] = ['i', p.idx, p.inst];
        }
        return grid;
      }
      
      // æ”¶é›†æ‰€æœ‰æœ€ä¼˜è§£å¹¶è§£å‹ç¼©
      const allBestSolutions = [];
      const solutionKeys = new Set(); // ç”¨äºä¸»çº¿ç¨‹æœ€ç»ˆå»é‡
      
      for (const result of successfulResults) {
        if (result.bestFilled === globalBestFilled) {
          for (const solution of result.solutions) {
            // è®¡ç®—è§£å†³æ–¹æ¡ˆçš„å”¯ä¸€é”®
            const usedCounts = Array(ITEM_SHAPES.length).fill(0);
            const instanceCounts = new Map();
            
            for (const p of solution.compressed.placements) {
              const key = `${p.idx}_${p.inst}`;
              if (!instanceCounts.has(key)) {
                instanceCounts.set(key, 0);
                usedCounts[p.idx]++;
              }
            }
            
            const solutionKey = usedCounts.join(',');
            if (!solutionKeys.has(solutionKey)) {
              solutionKeys.add(solutionKey);
              
              // åªåœ¨éœ€è¦æ—¶è§£å‹ç¼©ç½‘æ ¼
              const decompressedGrid = decompressGridInMain(solution.compressed, grid);
              
              allBestSolutions.push({
                filled: solution.filled,
                grid: decompressedGrid,
                counts: result.counts
              });
              
              // é™åˆ¶æœ€ç»ˆè§£å†³æ–¹æ¡ˆæ•°é‡ï¼Œé˜²æ­¢ä¸»çº¿ç¨‹å†…å­˜æº¢å‡º
              if (allBestSolutions.length >= 50) {
                console.log('è¾¾åˆ°è§£å†³æ–¹æ¡ˆæ•°é‡é™åˆ¶ï¼Œåœæ­¢æ”¶é›†æ›´å¤šæ–¹æ¡ˆ');
                break;
              }
            }
          }
        }
        
        if (allBestSolutions.length >= 50) break;
      }
      
      console.log(`æœ€ç»ˆæ”¶é›†åˆ° ${allBestSolutions.length} ä¸ªä¸åŒçš„æœ€ä¼˜è§£å†³æ–¹æ¡ˆ`);
      
      return { 
        bestFilled: globalBestFilled, 
        solutions: allBestSolutions 
      };
    }



    function formatResultJSGrid(bestGrid, originalGrid) {
      const totalFree = computeFreeCells(originalGrid);
      const filled = countFilled(bestGrid);
      const util = totalFree === 0 ? 0 : filled / totalFree;
      const vis = [];
      const idGrid = [];
      for (let i = 0; i < bestGrid.length; i++) {
        const row = [];
        const idRow = [];
        for (let j = 0; j < bestGrid[0].length; j++) {
          const cell = bestGrid[i][j];
          if (cell === 'x' && originalGrid[i][j] === 'o') row.push('o');
          else if (cell === 'x' || cell === 'o') row.push(cell);
          else if (Array.isArray(cell)) {
            const idx = cell[1];
            row.push(String.fromCharCode(65 + (idx % 26)));
          } else row.push(cell);
          // id grid: store item idx and instance id if present
          if (Array.isArray(cell) && cell[0] === 'i') {
            idRow.push({ idx: cell[1], inst: cell[2] });
          } else {
            idRow.push(null);
          }
        }
        vis.push(row);
        idGrid.push(idRow);
      }
      return { util, vis, idGrid };
    }

    function renderVis(grid, idGrid) {
      const rows = grid.length, cols = grid[0]?.length || 0;
      visEl.style.gridTemplateColumns = `repeat(${cols}, 24px)`;
      visEl.innerHTML = '';
      // Build high-contrast colors for instances and ensure adjacent instances differ strongly
      function keyOf(info) { return info ? `${info.idx}#${info.inst}` : '' }
      function listInstances() {
        const set = new Set();
        for (let r = 0; r < rows; r++) for (let c = 0; c < cols; c++) {
          const info = idGrid ? idGrid[r][c] : null;
          if (info) set.add(keyOf(info));
        }
        return Array.from(set);
      }
      function buildAdj() {
        const adj = new Map();
        const add = (a, b) => { if (!adj.has(a)) adj.set(a, new Set()); if (!adj.has(b)) adj.set(b, new Set()); if (a !== b) { adj.get(a).add(b); adj.get(b).add(a); } };
        for (let r = 0; r < rows; r++) for (let c = 0; c < cols; c++) {
          const a = idGrid ? idGrid[r][c] : null; if (!a) continue;
          const ka = keyOf(a);
          if (r + 1 < rows) { const b = idGrid[r + 1][c]; if (b && keyOf(b) !== ka) add(ka, keyOf(b)); }
          if (c + 1 < cols) { const b = idGrid[r][c + 1]; if (b && keyOf(b) !== ka) add(ka, keyOf(b)); }
        }
        return adj;
      }
      function generatePalette() {
        const hs = []; for (let h = 0; h < 360; h += 30) hs.push(h);
        const palette = [];
        const sats = [75, 85];
        const lights = [45, 55];
        for (const h of hs) {
          for (const s of sats) { for (const l of lights) { palette.push({ h, s, l }); } }
        }
        return palette;
      }
      function hueDist(a, b) {
        const d = Math.abs(a - b) % 360; return Math.min(d, 360 - d);
      }
      function colorDistance(c1, c2) {
        if (!c1 || !c2) return 360;
        return hueDist(c1.h, c2.h) + Math.abs((c1.l || 0) - (c2.l || 0)) * 0.5 + Math.abs((c1.s || 0) - (c2.s || 0)) * 0.2;
      }
      function toCss(c) { return `hsl(${c.h}deg ${c.s}% ${c.l}%)`; }
      function darker(c, dl = 15) { return { h: c.h, s: c.s, l: Math.max(10, c.l - dl) }; }
      function textColor(c) { return (c.l < 50) ? '#ffffff' : '#111827'; }
      function assignColors(adj) {
        const nodes = listInstances();
        const palette = generatePalette();
        // order by degree desc
        const degree = new Map();
        nodes.forEach(k => degree.set(k, (adj.get(k)?.size) || 0));
        nodes.sort((a, b) => ((degree.get(b) || 0) - (degree.get(a) || 0)));
        const colorMap = new Map();
        for (const k of nodes) {
          const neighborColors = Array.from(adj.get(k) || []).map(n => colorMap.get(n)).filter(Boolean);
          let best = null, bestScore = -1;
          for (const c of palette) {
            const minDist = neighborColors.length ? Math.min(...neighborColors.map(nc => colorDistance(c, nc))) : 360;
            if (minDist > bestScore) { bestScore = minDist; best = c; }
          }
          // fallback in unlikely case
          colorMap.set(k, best || palette[0]);
        }
        return colorMap;
      }
      const adj = idGrid ? buildAdj() : new Map();
      const colorMap = idGrid ? assignColors(adj) : new Map();
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          const div = document.createElement('div');
          div.className = 'cell';
          const v = grid[r][c];
          const info = idGrid ? idGrid[r][c] : null;
          if (v === 'x') { div.classList.add('block'); div.textContent = 'x'; }
          else if (v === 'o') { div.classList.add('free'); div.textContent = ''; }
          else {
            div.classList.add('free');
            div.textContent = v;
          }
          // Fill color per item instance (no colored borders needed)
          if (info) {
            const k = keyOf(info);
            const colObj = colorMap.get(k);
            if (colObj) {
              const fill = toCss(colObj);
              div.style.backgroundColor = fill;
              div.style.color = textColor(colObj);
            }
          }
          visEl.appendChild(div);
        }
      }
    }

    function renderCountsSummary(usedCounts) {
      const summaryEl = document.getElementById('countsSummary');
      summaryEl.innerHTML = ''; // æ¸…ç©ºå†…å®¹
      
      const hasUsedItems = usedCounts.some(count => count > 0);
      if (!hasUsedItems) {
        summaryEl.textContent = '';
        return;
      }
      
      // åˆ›å»ºæ ‡é¢˜
      const titleSpan = document.createElement('span');
      titleSpan.textContent = 'ä½¿ç”¨æ•°é‡ï¼š';
      titleSpan.style.marginRight = '8px';
      summaryEl.appendChild(titleSpan);
      
      // ä¸ºæ¯ä¸ªä½¿ç”¨çš„ç‰©å“åˆ›å»ºå½¢çŠ¶æ˜¾ç¤º
      for (let idx = 0; idx < ITEM_SHAPES.length; idx++) {
        const provided = counts[idx] || 0; // ç”¨æˆ·æä¾›çš„æ•°é‡
        if (provided <= 0) continue; // åªæ˜¾ç¤ºç”¨æˆ·è®¾ç½®äº†æ•°é‡çš„ç‰©å“
        
        const used = usedCounts[idx] || 0;
        const remain = Math.max(0, provided - used);
        
        // åˆ›å»ºç‰©å“å®¹å™¨
        const itemContainer = document.createElement('span');
        itemContainer.style.display = 'inline-flex';
        itemContainer.style.alignItems = 'center'; // å‚ç›´å±…ä¸­
        itemContainer.style.marginRight = '12px';
        itemContainer.style.marginBottom = '4px';
        itemContainer.style.verticalAlign = 'middle'; // ç¡®ä¿æ•´ä¸ªå®¹å™¨ç›¸å¯¹äºå…¶ä»–å†…å®¹å‚ç›´å±…ä¸­
        
        // åˆ›å»ºç¼©å°çš„å½¢çŠ¶æ˜¾ç¤º
        const shapeDiv = document.createElement('div');
        shapeDiv.className = 'shape';
        shapeDiv.style.display = 'inline-grid';
        shapeDiv.style.gap = '1px';
        shapeDiv.style.padding = '2px';
        shapeDiv.style.background = '#f9fafb';
        shapeDiv.style.border = '1px solid var(--border)';
        shapeDiv.style.borderRadius = '4px';
        shapeDiv.style.marginRight = '4px';

        
        const shape = ITEM_SHAPES[idx];
        shapeDiv.style.gridTemplateColumns = `repeat(${shape[0].length}, 6px)`;
        
        shape.forEach(row => {
          row.forEach(cell => {
            const sq = document.createElement('div');
            sq.style.width = '6px';
            sq.style.height = '6px';
            sq.style.border = '1px solid #cbd5e1';
            sq.style.borderRadius = '1px';
            sq.style.background = cell ? '#64748b' : '#fff';
            shapeDiv.appendChild(sq);
          });
        });
        
        // åˆ›å»ºæ•°é‡æ–‡æœ¬
        const countText = document.createElement('span');
        countText.style.fontSize = '12px';
        countText.style.color = 'var(--muted)';
        countText.style.lineHeight = '1'; // è®¾ç½®è¡Œé«˜ä¸º1ï¼Œé¿å…é¢å¤–çš„è¡Œé—´è·å½±å“å¯¹é½
        countText.textContent = remain > 0 ? `${used}(${remain})` : `${used}`;
        
        itemContainer.appendChild(shapeDiv);
        itemContainer.appendChild(countText);
        summaryEl.appendChild(itemContainer);
      }
    }

    const solutionSelect = document.getElementById('solutionSelect');
    const solutionCountEl = document.getElementById('solutionCount');
    let solveTimer = null;
    let currentSolutions = [];
    let progressTimeout = null; // è¿›åº¦æ¡æ˜¾ç¤ºçš„å®šæ—¶å™¨
    
    function loadAndDisplayResults() {
      const resultsData = loadResults();
      if (!resultsData || !resultsData.solutions || resultsData.solutions.length === 0) {
        // æ²¡æœ‰ä¿å­˜çš„ç»“æœï¼Œæ˜¾ç¤ºé»˜è®¤çŠ¶æ€
        utilEl.innerHTML = 'åˆ©ç”¨ç‡: --';
        visEl.innerHTML = '';
        document.getElementById('countsSummary').textContent = '';
        solutionCountEl.textContent = 'è§£æ³•ï¼š0ç§';
        solutionSelect.innerHTML = '';
        renderVis(Array.from({ length: SIZE }, () => Array.from({ length: SIZE }, () => 'o')));
        return;
      }
      
      const { solutions, selectedIndex } = resultsData;
      currentSolutions = solutions;
      const totalFree = computeFreeCells(pkg);
      
      // é‡å»ºé€‰é¡¹
      solutionSelect.innerHTML = '';
      solutionCountEl.textContent = `è§£æ³•ï¼š${solutions.length}ç§`;
      
      solutions.forEach((s, i) => {
        const opt = document.createElement('option');
        opt.value = String(i);
        opt.textContent = `æ–¹æ¡ˆ ${i + 1}`;
        solutionSelect.appendChild(opt);
        opt.dataset.counts = JSON.stringify(s.counts);
      });
      
      // é€‰æ‹©ä¹‹å‰ä¿å­˜çš„æ–¹æ¡ˆ
      const validIndex = Math.min(selectedIndex || 0, solutions.length - 1);
      solutionSelect.value = String(validIndex);
      
      // æ˜¾ç¤ºé€‰ä¸­çš„æ–¹æ¡ˆ
      const selectedSolution = solutions[validIndex];
      const { util, vis, idGrid } = formatResultJSGrid(selectedSolution.grid, pkg);
      utilEl.innerHTML = `åˆ©ç”¨ç‡: <strong>${(util * 100).toFixed(2)}%</strong>`;
      renderVis(vis, idGrid);
      
      const opt = solutionSelect.options[validIndex];
      if (opt && opt.dataset.counts) {
        renderCountsSummary(JSON.parse(opt.dataset.counts));
      }
    }
    
    // æ¸…ç©ºå½“å‰æ˜¾ç¤ºçš„ç»“æœ
    function clearCurrentResults() {
      utilEl.innerHTML = 'åˆ©ç”¨ç‡: --';
      visEl.innerHTML = '';
      document.getElementById('countsSummary').textContent = '';
      solutionCountEl.textContent = 'è§£æ³•ï¼š0ç§';
      solutionSelect.innerHTML = '';
      currentSolutions = [];
      // æ˜¾ç¤ºç©ºçš„ç½‘æ ¼
      renderVis(Array.from({ length: SIZE }, () => Array.from({ length: SIZE }, () => 'o')));
    }
    
    // æ›´æ–°æŒ‰é’®çŠ¶æ€
    function updateCalculateButton(calculating) {
      const calculateBtn = document.getElementById('calculate');
      if (calculating) {
        calculateBtn.textContent = 'å–æ¶ˆè®¡ç®—';
        calculateBtn.classList.add('cancel');
      } else {
        calculateBtn.textContent = 'è®¡ç®—ç»“æœ';
        calculateBtn.classList.remove('cancel');
      }
    }
    
    // å–æ¶ˆå½“å‰è®¡ç®—
    function cancelCalculation() {
      if (!isCalculating) return;
      
      console.log('ç”¨æˆ·å–æ¶ˆè®¡ç®—');
      isCalculating = false;
      
      // æ¸…é™¤è¿›åº¦æ¡æ˜¾ç¤ºçš„å®šæ—¶å™¨
      if (progressTimeout) {
        clearTimeout(progressTimeout);
        progressTimeout = null;
      }
      
      // è®¾ç½®å–æ¶ˆæ ‡è®°
      if (currentCalculationPromise && currentCalculationPromise.cancelToken) {
        currentCalculationPromise.cancelToken.cancelled = true;
      }
      
      // ç»ˆæ­¢æ‰€æœ‰Worker
      terminateAllWorkers();
      
      // éšè—è¿›åº¦æ¡å’Œé®ç½©
      const progressContainer = document.getElementById('progressContainer');
      const resultOverlay = document.getElementById('resultOverlay');
      progressContainer.style.display = 'none';
      resultOverlay.classList.remove('show');
      
      // æ¢å¤æŒ‰é’®çŠ¶æ€
      updateCalculateButton(false);
      
      console.log('è®¡ç®—å·²å–æ¶ˆ');
    }
    
    function requestSolve() {
      // å¦‚æœæ­£åœ¨è®¡ç®—ï¼Œåˆ™å–æ¶ˆè®¡ç®—
      if (isCalculating) {
        cancelCalculation();
        return;
      }
      
      // æ£€æŸ¥æ˜¯å¦æœ‰ç‰©å“æ•°é‡è®¾ç½®
      const hasItems = counts.some(count => count > 0);
      if (!hasItems) {
        // æ²¡æœ‰è®¾ç½®ä»»ä½•ç‰©å“æ•°é‡ï¼Œç›´æ¥æ˜¾ç¤ºç©ºç»“æœ
        clearCurrentResults();
        utilEl.innerHTML = 'åˆ©ç”¨ç‡: <strong>0.00%</strong>';
        solutionCountEl.textContent = 'è§£æ³•ï¼š0ç§';
        saveResults([]);
        return;
      }
      
      clearTimeout(solveTimer);
      solveTimer = setTimeout(() => {
        // æ ‡è®°å¼€å§‹è®¡ç®—
        isCalculating = true;
        
        // æ¸…ç©ºå½“å‰ç»“æœ
        clearCurrentResults();
        
        // æ›´æ–°æŒ‰é’®çŠ¶æ€
        updateCalculateButton(true);
        
        // è·å–è¿›åº¦æ¡å’Œé®ç½©å…ƒç´ 
        const progressContainer = document.getElementById('progressContainer');
        const progressFill = document.getElementById('progressFill');
        const progressText = document.getElementById('progressText');
        const resultOverlay = document.getElementById('resultOverlay');
        
        // åˆå§‹åŒ–è¿›åº¦æ¡çŠ¶æ€ï¼ˆä½†ä¸æ˜¾ç¤ºï¼‰
        progressFill.style.width = '0%';
        progressText.textContent = '0%';
        
        // è¿›åº¦å›è°ƒå‡½æ•°ï¼Œæ·»åŠ é˜²æŠ–å’Œå¹³æ»‘å¤„ç†
        let lastDisplayedProgress = 0;
        const updateProgress = (progress) => {
          const roundedProgress = Math.round(progress);
          // åªæœ‰å½“è¿›åº¦çœŸæ­£å¢åŠ æ—¶æ‰æ›´æ–°æ˜¾ç¤ºï¼Œé¿å…åå¤æ¨ªè·³
          if (roundedProgress > lastDisplayedProgress) {
            lastDisplayedProgress = roundedProgress;
            progressFill.style.width = `${roundedProgress}%`;
            progressText.textContent = `${roundedProgress}%`;
          }
        };
        
        // å»¶è¿Ÿ300æ¯«ç§’æ˜¾ç¤ºè¿›åº¦æ¡å’Œé®ç½©
        progressTimeout = setTimeout(() => {
          if (isCalculating) {
            progressContainer.style.display = 'flex';
            resultOverlay.classList.add('show');
          }
        }, 300);
        
        // ç«‹å³å¼€å§‹è®¡ç®—
        setTimeout(async () => {
          try {
            // åˆ›å»ºå–æ¶ˆä»¤ç‰Œ
            const cancelToken = { cancelled: false };
            
            // åˆ›å»ºè®¡ç®—Promiseå¹¶ä¿å­˜å¼•ç”¨
            currentCalculationPromise = solveWithNewArchitecture(pkg, ITEM_SHAPES, counts, updateProgress, cancelToken);
            currentCalculationPromise.cancelToken = cancelToken;
            
            // ä½¿ç”¨æ–°çš„ä¸‰é˜¶æ®µæ¶æ„è¿›è¡Œæ±‚è§£
            const { bestFilled, solutions } = await currentCalculationPromise;
            
            // è®¡ç®—å®Œæˆï¼Œå–æ¶ˆè¿›åº¦æ¡æ˜¾ç¤ºçš„å®šæ—¶å™¨
            clearTimeout(progressTimeout);
            
            // è®¡ç®—å®Œæˆåç«‹å³æ˜¾ç¤º100%
            updateProgress(100);
            
            // å¤„ç†ç»“æœï¼ˆsolutionså·²ç»åŒ…å«countsä¿¡æ¯ï¼Œæ— éœ€é‡æ–°æ¨å¯¼ï¼‰
            const totalFree = computeFreeCells(pkg);
            const seen = new Map(); // key -> {filled, grid, counts}
            const unique = [];
            
            for (const s of solutions) {
              // ä½¿ç”¨å·²æœ‰çš„countsä¿¡æ¯ï¼Œæˆ–è€…ä»gridæ¨å¯¼
              const countsToUse = s.counts || deriveCountsFromGrid(s.grid, ITEM_SHAPES.length);
              const key = countsToUse.join(',');
              if (!seen.has(key)) {
                const entry = { ...s, counts: countsToUse };
                seen.set(key, entry);
                unique.push(entry);
              }
            }
            
            currentSolutions = unique;
            
            // æ„å»ºé€‰é¡¹
            solutionSelect.innerHTML = '';
            if (unique.length === 0) {
              utilEl.innerHTML = 'åˆ©ç”¨ç‡: --';
              visEl.innerHTML = '';
              document.getElementById('countsSummary').textContent = '';
              solutionCountEl.textContent = 'è§£æ³•ï¼š0ç§';
              // ä¿å­˜ç©ºç»“æœ
              saveResults([]);
              return;
            }
            
            solutionCountEl.textContent = `è§£æ³•ï¼š${unique.length}ç§`;
            unique.forEach((s, i) => {
              const util = totalFree === 0 ? 0 : s.filled / totalFree;
              const opt = document.createElement('option');
              opt.value = String(i);
              opt.textContent = `æ–¹æ¡ˆ ${i + 1}`;
              solutionSelect.appendChild(opt);
              // Store counts for later
              opt.dataset.counts = JSON.stringify(s.counts);
            });
            
            // é»˜è®¤é€‰æ‹©ç¬¬ä¸€ä¸ªè§£å†³æ–¹æ¡ˆ
            solutionSelect.value = '0';
            const first = unique[0];
            const { util, vis, idGrid } = formatResultJSGrid(first.grid, pkg);
            utilEl.innerHTML = `åˆ©ç”¨ç‡: <strong>${(util * 100).toFixed(2)}%</strong>`;
            renderVis(vis, idGrid);
            renderCountsSummary(JSON.parse(solutionSelect.options[0].dataset.counts));
            
            // ä¿å­˜è®¡ç®—ç»“æœ
            saveResults(unique, 0);
            
            // éšè—è¿›åº¦æ¡å’Œé®ç½©
            progressContainer.style.display = 'none';
            resultOverlay.classList.remove('show');
            
          } catch (error) {
            console.error('è®¡ç®—è¿‡ç¨‹ä¸­å‡ºç°é”™è¯¯:', error);
            
            // è®¡ç®—å‡ºé”™ï¼Œå–æ¶ˆè¿›åº¦æ¡æ˜¾ç¤ºçš„å®šæ—¶å™¨
            clearTimeout(progressTimeout);
            
            // å¦‚æœæ˜¯å–æ¶ˆæ“ä½œï¼Œä¸æ˜¾ç¤ºé”™è¯¯ä¿¡æ¯
            if (error.message !== 'è®¡ç®—å·²å–æ¶ˆ') {
              utilEl.innerHTML = 'è®¡ç®—å‡ºé”™ï¼Œè¯·é‡è¯•';
            }
            
            progressContainer.style.display = 'none';
            resultOverlay.classList.remove('show');
          } finally {
            // æ¢å¤è®¡ç®—çŠ¶æ€å’ŒæŒ‰é’®
            isCalculating = false;
            updateCalculateButton(false);
            currentCalculationPromise = null;
          }
        }, 10); // çŸ­æš‚å»¶è¿Ÿè®©è¿›åº¦æ¡æ˜¾ç¤º
      }, 50);
    }

    solutionSelect.onchange = () => {
      const idx = parseInt(solutionSelect.value, 10);
      const s = currentSolutions[idx];
      const { util, vis, idGrid } = formatResultJSGrid(s.grid, pkg);
      utilEl.innerHTML = `åˆ©ç”¨ç‡: <strong>${(util * 100).toFixed(2)}%</strong>`;
      renderVis(vis, idGrid);
      const opt = solutionSelect.options[solutionSelect.selectedIndex];
      renderCountsSummary(JSON.parse(opt.dataset.counts || '[]'));
      
      // ä¿å­˜å½“å‰é€‰ä¸­çš„æ–¹æ¡ˆç´¢å¼•
      if (currentSolutions.length > 0) {
        saveResults(currentSolutions, idx);
      }
    };

    function init() {
      loadState();
      renderGrid();
      renderShapes();
      // è½½å…¥å¹¶æ˜¾ç¤ºä¸Šæ¬¡çš„è®¡ç®—ç»“æœ
      loadAndDisplayResults();
    }
    init();
  </script>
</body>

</html>
